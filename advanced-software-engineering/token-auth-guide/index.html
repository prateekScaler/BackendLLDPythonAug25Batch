<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Token Auth Implementation Guide</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            line-height: 1.7;
            min-height: 100vh;
        }
        .container { max-width: 1000px; margin: 0 auto; padding: 20px; }

        header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #1a4a1a 0%, #0f2f0f 100%);
            border-bottom: 3px solid #2ed573;
        }
        header h1 { color: #2ed573; font-size: 2.2em; margin-bottom: 10px; }
        header p { color: #aaa; }

        .step {
            background: #0f0f23;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2ed573;
            overflow: hidden;
        }
        .step-header {
            background: #1a1a3e;
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .step-header:hover { background: #252550; }
        .step-number {
            background: #2ed573;
            color: #0f0f23;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }
        .step-title { flex: 1; font-size: 1.2em; }
        .step-content { padding: 25px; display: none; }
        .step.active .step-content { display: block; }
        .step-toggle { font-size: 1.5em; transition: transform 0.3s; }
        .step.active .step-toggle { transform: rotate(45deg); }

        pre {
            background: #0a0a15;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9em;
            border: 1px solid #333;
            margin: 15px 0;
        }
        code { color: #ffd700; }
        .comment { color: #6a9955; }
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .function { color: #dcdcaa; }

        .quiz {
            background: linear-gradient(135deg, #1a3a2a 0%, #0f2a1a 100%);
            border: 2px solid #2ed573;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .quiz h4 { color: #2ed573; margin-bottom: 15px; }
        .quiz-options { display: flex; flex-direction: column; gap: 10px; }
        .quiz-option {
            background: #0f0f23;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid #333;
            transition: all 0.3s;
        }
        .quiz-option:hover { border-color: #2ed573; }
        .quiz-option.correct { background: #1a3a2a; border-color: #2ed573; }
        .quiz-option.wrong { background: #3a1a1a; border-color: #ff4757; }
        .quiz-feedback { margin-top: 15px; padding: 10px; border-radius: 8px; display: none; }

        .reveal-box {
            background: #1a1a3e;
            border: 2px dashed #2ed573;
            border-radius: 8px;
            margin: 15px 0;
            overflow: hidden;
        }
        .reveal-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .reveal-header:hover { background: #252550; }
        .reveal-content {
            padding: 0 20px 20px;
            display: none;
            border-top: 1px solid #333;
        }
        .reveal-box.open .reveal-content { display: block; }

        .diagram {
            background: #0a0a15;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            line-height: 1.4;
            overflow-x: auto;
        }

        .info-box {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid;
        }
        .info-box.tip { background: #1a3a2a; border-color: #2ed573; }
        .info-box.warning { background: #3a2a1a; border-color: #ffa502; }
        .info-box.question { background: #1a2a4a; border-color: #6eb5ff; }
        .info-box.danger { background: #3a1a1a; border-color: #ff4757; }

        .file-tree {
            background: #0a0a15;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .file-tree .folder { color: #ffd700; }
        .file-tree .file { color: #6eb5ff; }
        .file-tree .highlight { color: #2ed573; font-weight: bold; }

        .jwt-parts {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            font-family: monospace;
            margin: 15px 0;
        }
        .jwt-part {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .jwt-header { background: #ff6b6b; color: white; }
        .jwt-payload { background: #9b59b6; color: white; }
        .jwt-signature { background: #3498db; color: white; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        th { background: #1a1a3e; color: #2ed573; }
        tr:hover { background: #0f0f23; }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .comparison-box {
            background: #1a1a3e;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #333;
        }
        .comparison-box h4 { margin-bottom: 15px; }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        .nav-links a {
            color: #2ed573;
            text-decoration: none;
            padding: 10px 20px;
            background: #1a1a3e;
            border-radius: 8px;
        }
        .nav-links a:hover { background: #252550; }

        .progress-bar {
            background: #1a1a3e;
            height: 8px;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(90deg, #2ed573, #27ae60);
            height: 100%;
            width: 0%;
            transition: width 0.5s;
        }
    </style>
</head>
<body>
    <header>
        <h1>JWT Token Authentication</h1>
        <p>Implementation Guide for Django REST Framework</p>
        <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
    </header>

    <div class="container">
        <!-- Quick Concept -->
        <div class="step active" data-step="0">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">0</span>
                <span class="step-title">JWT Anatomy & Flow</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <h4>JWT Structure</h4>
                <div class="jwt-parts">
                    <span class="jwt-part jwt-header">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>
                    <span style="color: #666;">.</span>
                    <span class="jwt-part jwt-payload">eyJ1c2VyX2lkIjoxMjN9</span>
                    <span style="color: #666;">.</span>
                    <span class="jwt-part jwt-signature">SflKxwRJSMeKKF2QT4fwpM</span>
                </div>
                <div style="display: flex; gap: 20px; margin-top: 10px; font-size: 0.9em;">
                    <span><span class="jwt-part jwt-header" style="padding: 4px 8px;">Header</span> Algorithm + Type</span>
                    <span><span class="jwt-part jwt-payload" style="padding: 4px 8px;">Payload</span> Claims (user data)</span>
                    <span><span class="jwt-part jwt-signature" style="padding: 4px 8px;">Signature</span> Verification</span>
                </div>

                <div class="diagram" style="margin-top: 20px;">
<pre style="color: #eee; margin: 0;">
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Client  ‚îÇ                    ‚îÇ   Django    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ                                ‚îÇ
     ‚îÇ 1. POST /api/token/            ‚îÇ
     ‚îÇ    {username, password}        ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                                ‚îÇ 2. Verify credentials
     ‚îÇ                                ‚îÇ 3. Generate JWT (sign with SECRET_KEY)
     ‚îÇ 4. {access_token, refresh_token}
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ                                ‚îÇ
     ‚îÇ 5. GET /api/protected/         ‚îÇ
     ‚îÇ    Authorization: Bearer {jwt} ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ
     ‚îÇ                                ‚îÇ 6. Verify signature
     ‚îÇ                                ‚îÇ 7. Decode payload ‚Üí user_id
     ‚îÇ 8. Response                    ‚îÇ
     ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ

<span style="color: #2ed573;">Key Difference from Sessions: NO database lookup for each request!</span>
</pre>
                </div>

                <div class="quiz">
                    <h4>Quick Check</h4>
                    <p>JWTs are "stateless". What does this mean?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-stateless-quiz')">A. The server doesn't remember anything</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'jwt-stateless-quiz')">B. Server doesn't need to store session data - all info is in the token</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-stateless-quiz')">C. The token never changes state</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-stateless-quiz')">D. Users can't have state</div>
                    </div>
                    <div class="quiz-feedback" id="jwt-stateless-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="jwt-stateless-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Stateless vs Stateful Authentication</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <table>
                            <tr><th>Session (Stateful)</th><th>JWT (Stateless)</th></tr>
                            <tr>
                                <td>Server stores: <code>{session_id: user_data}</code></td>
                                <td>Server stores: <strong>nothing</strong></td>
                            </tr>
                            <tr>
                                <td>Cookie contains: <code>session_id</code></td>
                                <td>Token contains: <code>user_id, email, exp, ...</code></td>
                            </tr>
                            <tr>
                                <td>Every request ‚Üí DB lookup</td>
                                <td>Every request ‚Üí Just verify signature</td>
                            </tr>
                        </table>
                        <p style="margin-top: 15px;"><strong>Why "stateless" matters:</strong></p>
                        <ul>
                            <li>Horizontal scaling - any server can handle any request</li>
                            <li>No shared session store needed across servers</li>
                            <li>Better for microservices architecture</li>
                        </ul>
                    </div>
                </div>

                <div class="comparison">
                    <div class="comparison-box">
                        <h4 style="color: #e94560;">Session-Based</h4>
                        <ul>
                            <li>Session ID in cookie</li>
                            <li>Data stored on server</li>
                            <li>DB lookup every request</li>
                            <li>Easy to invalidate</li>
                        </ul>
                    </div>
                    <div class="comparison-box">
                        <h4 style="color: #2ed573;">Token-Based (JWT)</h4>
                        <ul>
                            <li>Token in header</li>
                            <li>Data inside token</li>
                            <li>No DB lookup needed</li>
                            <li>Can't invalidate easily*</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 1: Install & Configure -->
        <div class="step" data-step="1">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">1</span>
                <span class="step-title">Install & Configure SimpleJWT</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <h4>Install the package</h4>
<pre><code>pip install djangorestframework-simplejwt</code></pre>

                <h4>settings.py</h4>
<pre><code>INSTALLED_APPS = [
    <span class="comment"># ...</span>
    <span class="string">'rest_framework'</span>,
    <span class="string">'rest_framework_simplejwt'</span>,
]

REST_FRAMEWORK = {
    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [
        <span class="comment"># Try commenting this out - what happens?</span>
        <span class="string">'rest_framework_simplejwt.authentication.JWTAuthentication'</span>,
    ],
}

<span class="comment"># JWT Settings (customize these!)</span>
<span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta

SIMPLE_JWT = {
    <span class="comment"># How long until access token expires?</span>
    <span class="string">'ACCESS_TOKEN_LIFETIME'</span>: timedelta(minutes=15),

    <span class="comment"># How long until refresh token expires?</span>
    <span class="string">'REFRESH_TOKEN_LIFETIME'</span>: timedelta(days=7),

    <span class="comment"># Rotate refresh tokens on use?</span>
    <span class="string">'ROTATE_REFRESH_TOKENS'</span>: <span class="keyword">True</span>,

    <span class="comment"># Blacklist old refresh tokens?</span>
    <span class="string">'BLACKLIST_AFTER_ROTATION'</span>: <span class="keyword">True</span>,

    <span class="comment"># Algorithm for signing (HMAC-SHA256)</span>
    <span class="string">'ALGORITHM'</span>: <span class="string">'HS256'</span>,

    <span class="comment"># Key used for signing - uses Django's SECRET_KEY by default</span>
    <span class="string">'SIGNING_KEY'</span>: SECRET_KEY,

    <span class="comment"># Header format: "Authorization: Bearer <token>"</span>
    <span class="string">'AUTH_HEADER_TYPES'</span>: (<span class="string">'Bearer'</span>,),
}
</code></pre>

                <div class="quiz">
                    <h4>Security Question</h4>
                    <p>Why should ACCESS_TOKEN_LIFETIME be short (e.g., 15 min)?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'token-lifetime-quiz')">A. To save server memory</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'token-lifetime-quiz')">B. Limits damage if token is stolen - it expires quickly</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'token-lifetime-quiz')">C. Faster network performance</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'token-lifetime-quiz')">D. JWT standard requires it</div>
                    </div>
                    <div class="quiz-feedback" id="token-lifetime-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="token-lifetime-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #3a2a1a;">
                        <span>‚ö†Ô∏è</span> <strong style="color: #ffa502;">The JWT Can't-Invalidate Problem</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>Unlike sessions, JWTs can't be invalidated server-side:</strong></p>
<pre><code><span class="comment"># Session: Easy to invalidate</span>
Session.objects.filter(user=hacked_user).delete()  <span class="comment">‚Üê Done!</span>

<span class="comment"># JWT: Token is self-contained</span>
<span class="comment"># Even if you know it's stolen, it's still valid until exp!</span>
</code></pre>
                        <p style="margin-top: 10px;"><strong>Short lifetime = damage limitation:</strong></p>
                        <ul>
                            <li>Token stolen? Attacker has max 15 minutes</li>
                            <li>User's permissions changed? Takes effect in 15 min</li>
                            <li>User logged out? Can't use refresh token, access expires soon</li>
                        </ul>
                        <p style="margin-top: 10px; color: #888;">Trade-off: Shorter = more secure but more refresh requests. 15-30 min is common.</p>
                    </div>
                </div>

                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üîê</span> Why HS256? What about RS256?
                    </div>
                    <div class="reveal-content">
                        <table>
                            <tr><th>Algorithm</th><th>Type</th><th>Use Case</th></tr>
                            <tr>
                                <td><code>HS256</code></td>
                                <td>Symmetric (same key signs & verifies)</td>
                                <td>Single service, simpler</td>
                            </tr>
                            <tr>
                                <td><code>RS256</code></td>
                                <td>Asymmetric (private key signs, public verifies)</td>
                                <td>Microservices, external verification</td>
                            </tr>
                        </table>
                        <p style="margin-top: 10px; color: #6eb5ff;">
                            <strong>Microservices example:</strong> Auth service signs with private key.
                            Other services verify with public key (can't forge tokens).
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 2: URL Setup -->
        <div class="step" data-step="2">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">2</span>
                <span class="step-title">Set Up Token URLs</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üß†</span> <strong>Recall Quiz:</strong> What's the <code>include()</code> function in Django URLs? Why use it?
                    </div>
                    <div class="reveal-content">
                        <p><strong>include()</strong> lets you reference other URL configurations - modular URL routing!</p>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.95em;">
<span class="comment"># myproject/urls.py - Main URL config</span>
urlpatterns = [
    path(<span class="string">'api/auth/'</span>, include(<span class="string">'users.urls'</span>)),  <span class="comment"># Delegates to users app</span>
    path(<span class="string">'api/products/'</span>, include(<span class="string">'products.urls'</span>)),
]

<span class="comment"># users/urls.py - App-level URLs</span>
urlpatterns = [
    path(<span class="string">'login/'</span>, LoginView.as_view()),  <span class="comment"># ‚Üí /api/auth/login/</span>
    path(<span class="string">'profile/'</span>, ProfileView.as_view()),  <span class="comment"># ‚Üí /api/auth/profile/</span>
]
</pre>
                        </div>
                        <p style="color: #2ed573;"><strong>Benefits:</strong> Each app manages its own URLs. Easy to add/remove apps. Cleaner organization.</p>
                    </div>
                </div>

                <h4>urls.py</h4>
<pre><code><span class="keyword">from</span> django.urls <span class="keyword">import</span> path
<span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> (
    TokenObtainPairView,   <span class="comment"># Login - returns access + refresh</span>
    TokenRefreshView,      <span class="comment"># Get new access using refresh</span>
    TokenVerifyView,       <span class="comment"># Check if token is valid</span>
)

urlpatterns = [
    <span class="comment"># These are built-in views - no code needed!</span>
    path(<span class="string">'api/token/'</span>, TokenObtainPairView.as_view(), name=<span class="string">'token_obtain_pair'</span>),
    path(<span class="string">'api/token/refresh/'</span>, TokenRefreshView.as_view(), name=<span class="string">'token_refresh'</span>),
    path(<span class="string">'api/token/verify/'</span>, TokenVerifyView.as_view(), name=<span class="string">'token_verify'</span>),
]
</code></pre>

                <h4 style="margin-top: 20px;">What each endpoint does:</h4>
                <table>
                    <tr><th>Endpoint</th><th>Method</th><th>Input</th><th>Output</th></tr>
                    <tr>
                        <td><code>/api/token/</code></td>
                        <td>POST</td>
                        <td><code>{"username", "password"}</code></td>
                        <td><code>{"access", "refresh"}</code></td>
                    </tr>
                    <tr>
                        <td><code>/api/token/refresh/</code></td>
                        <td>POST</td>
                        <td><code>{"refresh"}</code></td>
                        <td><code>{"access"}</code></td>
                    </tr>
                    <tr>
                        <td><code>/api/token/verify/</code></td>
                        <td>POST</td>
                        <td><code>{"token"}</code></td>
                        <td><code>{}</code> or 401</td>
                    </tr>
                </table>

                <div class="quiz">
                    <h4>REST Design</h4>
                    <p>Some argue <code>/api/token/</code> should be <code>/api/auth/</code>. What REST principle relates to URL naming?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'rest-design-quiz')">A. Statelessness</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'rest-design-quiz')">B. Uniform Interface - resources should be nouns</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'rest-design-quiz')">C. Layered System</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'rest-design-quiz')">D. Code on Demand</div>
                    </div>
                    <div class="quiz-feedback" id="rest-design-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="rest-design-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">REST Principles & URL Naming</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>The 6 REST Architectural Constraints:</strong></p>
                        <table>
                            <tr><th>Principle</th><th>Meaning</th></tr>
                            <tr><td>Client-Server</td><td>Separate UI from data storage</td></tr>
                            <tr><td>Stateless</td><td>Each request contains all info needed (no server-side session)</td></tr>
                            <tr><td>Cacheable</td><td>Responses must define if they're cacheable</td></tr>
                            <tr><td>Layered System</td><td>Client can't tell if connected directly to server</td></tr>
                            <tr><td style="color: #2ed573;"><strong>Uniform Interface</strong></td><td><strong>Standardized way to interact with resources</strong></td></tr>
                            <tr><td>Code on Demand</td><td>(Optional) Server can send executable code</td></tr>
                        </table>

                        <h4 style="margin-top: 20px; color: #6eb5ff;">Uniform Interface: URLs should be NOUNS (resources), not VERBS (actions)</h4>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.9em;">
<span style="color: #ff6b6b;">‚ùå Bad (verbs/actions in URL):</span>
POST /api/getUsers
POST /api/createUser
POST /api/deleteUser/5
POST /api/login          ‚Üê action
POST /api/authenticate   ‚Üê action

<span style="color: #2ed573;">‚úÖ Good (nouns/resources in URL):</span>
GET    /api/users        ‚Üê get all users
POST   /api/users        ‚Üê create user
DELETE /api/users/5      ‚Üê delete user 5
POST   /api/tokens       ‚Üê create a token (login)
DELETE /api/tokens       ‚Üê delete token (logout)
POST   /api/sessions     ‚Üê create session (alternative)
</pre>
                        </div>

                        <p><strong>The HTTP method IS the verb:</strong></p>
                        <table>
                            <tr><th>Method</th><th>Action</th><th>Example</th></tr>
                            <tr><td>GET</td><td>Read</td><td><code>GET /api/users</code> ‚Üí list users</td></tr>
                            <tr><td>POST</td><td>Create</td><td><code>POST /api/tokens</code> ‚Üí create token (login)</td></tr>
                            <tr><td>PUT</td><td>Replace</td><td><code>PUT /api/users/5</code> ‚Üí replace user 5</td></tr>
                            <tr><td>PATCH</td><td>Update</td><td><code>PATCH /api/users/5</code> ‚Üí partial update</td></tr>
                            <tr><td>DELETE</td><td>Delete</td><td><code>DELETE /api/tokens</code> ‚Üí delete token (logout)</td></tr>
                        </table>

                        <div class="info-box tip" style="margin-top: 15px;">
                            <strong>So why do we still use <code>/api/token/</code>?</strong>
                            <p style="margin-top: 5px;">
                                Pragmatism! <code>/login/</code> and <code>/token/</code> are universally understood.
                                Pure REST would be <code>POST /api/tokens</code> (create token) and <code>DELETE /api/tokens</code> (logout).
                                Both approaches work - consistency within your API matters more than strict REST purity.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Custom Token Claims -->
        <div class="step" data-step="3">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">3</span>
                <span class="step-title">Customize Token Payload</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <div class="quiz" style="margin-bottom: 20px;">
                    <h4>üß† Recall: OOP Concepts</h4>
                    <p>In OOP, when should you use inheritance vs composition?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'oop-recall')">A. Always use inheritance - it's more Pythonic</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'oop-recall')">B. Inheritance for "is-a" relationships, Composition for "has-a"</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'oop-recall')">C. Always use composition - inheritance is deprecated</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'oop-recall')">D. They're interchangeable</div>
                    </div>
                    <div class="quiz-feedback" id="oop-recall-feedback"></div>
                </div>
                <div class="reveal-box" id="oop-recall-explanation" style="display: none; margin-bottom: 20px;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">In this code, we USE inheritance (extending TokenObtainPairSerializer)</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre style="color: #eee; margin: 0; font-size: 0.95em;">
<span class="comment"># Inheritance: CustomSerializer IS-A TokenObtainPairSerializer</span>
class CustomTokenSerializer(TokenObtainPairSerializer):  <span class="comment"># Inherits</span>
    def get_token(cls, user):
        token = super().get_token(user)  <span class="comment"># Use parent's method</span>
        token['custom'] = 'data'
        return token

<span class="comment"># Composition: View HAS-A Serializer</span>
class MyView(APIView):
    serializer_class = CustomTokenSerializer  <span class="comment"># Contains, doesn't inherit</span>
</pre>
                    </div>
                </div>

                <p>By default, JWT only contains <code>user_id</code>. Let's add more claims!</p>

                <h4>users/serializers.py</h4>
<pre><code><span class="keyword">from</span> rest_framework_simplejwt.serializers <span class="keyword">import</span> TokenObtainPairSerializer

<span class="keyword">class</span> <span class="function">CustomTokenObtainPairSerializer</span>(TokenObtainPairSerializer):
    <span class="string">"""Add custom claims to JWT payload"""</span>

    @classmethod
    <span class="keyword">def</span> <span class="function">get_token</span>(cls, user):
        <span class="comment"># Get the default token</span>
        token = <span class="keyword">super</span>().get_token(user)

        <span class="comment"># Add custom claims (these go in the payload!)</span>
        token[<span class="string">'username'</span>] = user.username
        token[<span class="string">'email'</span>] = user.email
        token[<span class="string">'is_staff'</span>] = user.is_staff

        <span class="comment"># Try adding more! e.g., roles, permissions</span>
        <span class="comment"># token['roles'] = list(user.groups.values_list('name', flat=True))</span>

        <span class="keyword">return</span> token
</code></pre>

                <h4>users/views.py</h4>
<pre><code><span class="keyword">from</span> rest_framework_simplejwt.views <span class="keyword">import</span> TokenObtainPairView
<span class="keyword">from</span> .serializers <span class="keyword">import</span> CustomTokenObtainPairSerializer

<span class="keyword">class</span> <span class="function">CustomTokenObtainPairView</span>(TokenObtainPairView):
    serializer_class = CustomTokenObtainPairSerializer
</code></pre>

                <h4>Update urls.py</h4>
<pre><code><span class="keyword">from</span> users.views <span class="keyword">import</span> CustomTokenObtainPairView

urlpatterns = [
    path(<span class="string">'api/token/'</span>, CustomTokenObtainPairView.as_view()),  <span class="comment"># Use custom view</span>
    <span class="comment"># ...</span>
]
</code></pre>

                <div class="info-box warning">
                    <strong>Warning:</strong> Don't put sensitive data in JWT payload!
                    <p style="margin-top: 5px;">
                        Anyone can decode the payload (it's just Base64). Only the signature is secret.
                    </p>
                </div>

                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üîç</span> Try: Decode a JWT and see what's inside
                    </div>
                    <div class="reveal-content">
<pre><code><span class="comment"># In Python:</span>
<span class="keyword">import</span> base64
<span class="keyword">import</span> json

jwt = <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxfQ.xxx"</span>
payload = jwt.split(<span class="string">'.'</span>)[1]

<span class="comment"># Add padding if needed</span>
payload += <span class="string">'='</span> * (4 - len(payload) % 4)

decoded = json.loads(base64.urlsafe_b64decode(payload))
print(decoded)  <span class="comment"># {'user_id': 1}</span>
</code></pre>
                        <p style="margin-top: 10px;">Or use <a href="https://jwt.io" target="_blank" style="color: #2ed573;">jwt.io</a> to decode visually!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 4: Protected Views -->
        <div class="step" data-step="4">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">4</span>
                <span class="step-title">Protect Your Views</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üß†</span> <strong>Recall Quiz:</strong> What's a Python decorator? How does <code>@staticmethod</code> work?
                    </div>
                    <div class="reveal-content">
                        <p><strong>Decorator:</strong> A function that takes a function and returns a modified function.</p>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.95em;">
<span class="comment"># @api_view is a decorator that wraps your function</span>
@api_view([<span class="string">'GET'</span>])
def my_view(request):
    return Response({})

<span class="comment"># @staticmethod - method doesn't access instance (self) or class (cls)</span>
class MyClass:
    @staticmethod
    def utility_func(x, y):  <span class="comment"># No self parameter!</span>
        return x + y

<span class="comment"># @classmethod - method accesses the class, not instance</span>
class MyClass:
    @classmethod
    def get_token(cls, user):  <span class="comment"># Gets class as first arg</span>
        return cls()  <span class="comment"># Can create instances</span>
</pre>
                        </div>
                    </div>
                </div>

                <h4>Method 1: Permission Classes (Class-Based Views)</h4>
<pre><code><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView
<span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated
<span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response

<span class="keyword">class</span> <span class="function">ProtectedView</span>(APIView):
    permission_classes = [IsAuthenticated]

    <span class="keyword">def</span> <span class="function">get</span>(self, request):
        <span class="comment"># request.user is set automatically by JWTAuthentication</span>
        <span class="keyword">return</span> Response({
            <span class="string">'message'</span>: f<span class="string">'Hello, {request.user.username}!'</span>,
            <span class="string">'user_id'</span>: request.user.id
        })
</code></pre>

                <h4>Method 2: Decorators (Function-Based Views)</h4>
<pre><code><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view, permission_classes
<span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated

@api_view([<span class="string">'GET'</span>])
@permission_classes([IsAuthenticated])
<span class="keyword">def</span> <span class="function">protected_view</span>(request):
    <span class="keyword">return</span> Response({<span class="string">'user'</span>: request.user.username})
</code></pre>

                <h4>Method 3: Global Default</h4>
<pre><code><span class="comment"># settings.py - Require auth for ALL views by default</span>
REST_FRAMEWORK = {
    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: [
        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>,
    ],
}

<span class="comment"># Then explicitly allow public views:</span>
<span class="keyword">class</span> <span class="function">PublicView</span>(APIView):
    permission_classes = []  <span class="comment"># Override - no auth needed</span>
</code></pre>

                <div class="quiz">
                    <h4>How does DRF know to use JWT?</h4>
                    <p>We didn't write any JWT code in the view. How does <code>request.user</code> get populated?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'drf-jwt-quiz')">A. Django's AuthenticationMiddleware</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'drf-jwt-quiz')">B. JWTAuthentication class in DEFAULT_AUTHENTICATION_CLASSES</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'drf-jwt-quiz')">C. The permission class does it</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'drf-jwt-quiz')">D. Magic</div>
                    </div>
                    <div class="quiz-feedback" id="drf-jwt-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="drf-jwt-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">DRF's Authentication Pipeline</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="comment"># settings.py tells DRF which authenticators to try:</span>
REST_FRAMEWORK = {
    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [
        <span class="string">'rest_framework_simplejwt.authentication.JWTAuthentication'</span>,
    ],
}

<span class="comment"># For each request, DRF does:</span>
1. Loop through authentication classes
2. Call each class's authenticate(request) method
3. First one that returns (user, token) wins
4. Sets request.user = user
</code></pre>
                        <p style="margin-top: 10px;"><strong>The flow:</strong></p>
                        <ul>
                            <li>Request arrives with <code>Authorization: Bearer xyz...</code></li>
                            <li>JWTAuthentication extracts token, verifies signature</li>
                            <li>Decodes payload, gets user_id</li>
                            <li>Fetches User from DB, sets <code>request.user</code></li>
                        </ul>
                        <p style="margin-top: 10px; color: #888;">Your view code stays clean - authentication happens before your view runs!</p>
                    </div>
                </div>

                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üîß</span> How JWTAuthentication works internally
                    </div>
                    <div class="reveal-content">
<pre><code><span class="comment"># Simplified version of what JWTAuthentication does:</span>

<span class="keyword">class</span> <span class="function">JWTAuthentication</span>:
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request):
        <span class="comment"># 1. Get token from header</span>
        header = request.headers.get(<span class="string">'Authorization'</span>)
        <span class="comment"># "Bearer eyJ..."</span>

        <span class="comment"># 2. Extract token</span>
        token = header.split()[1]

        <span class="comment"># 3. Verify signature using SECRET_KEY</span>
        payload = jwt.decode(token, SECRET_KEY, algorithms=[<span class="string">'HS256'</span>])

        <span class="comment"># 4. Get user from payload</span>
        user = User.objects.get(id=payload[<span class="string">'user_id'</span>])

        <span class="keyword">return</span> (user, token)
</code></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 5: Token Refresh Flow -->
        <div class="step" data-step="5">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">5</span>
                <span class="step-title">Token Refresh Strategy</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <div class="diagram">
<pre style="color: #eee; margin: 0;">
Access Token Lifecycle:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

0 min        15 min (expired)
|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|
    Access Token
    (short-lived)

Client Flow:
1. Use access token for API calls
2. Get 401 Unauthorized? Token expired!
3. Use refresh token to get new access token
4. Retry original request

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Refresh Token (7 days)                             ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Access Token 1 (15 min) ‚îÄ‚îÄexpired‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Access Token 2 (15 min) ‚îÄ‚îÄexpired‚îÄ‚îÄ‚î§ (refresh) ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Access Token 3 (15 min)            ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ ...                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
                </div>

                <h4>Frontend Implementation Pattern</h4>
<pre><code><span class="comment">// JavaScript (conceptual)</span>
<span class="keyword">async function</span> <span class="function">apiCall</span>(url, options) {
    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url, {
        ...options,
        headers: {
            <span class="string">'Authorization'</span>: <span class="string">`Bearer ${accessToken}`</span>
        }
    });

    <span class="comment">// Token expired?</span>
    <span class="keyword">if</span> (response.status === 401) {
        <span class="comment">// Try to refresh</span>
        <span class="keyword">const</span> newTokens = <span class="keyword">await</span> refreshTokens();

        <span class="keyword">if</span> (newTokens) {
            <span class="comment">// Retry with new token</span>
            response = <span class="keyword">await</span> fetch(url, {
                ...options,
                headers: {
                    <span class="string">'Authorization'</span>: <span class="string">`Bearer ${newTokens.access}`</span>
                }
            });
        } <span class="keyword">else</span> {
            <span class="comment">// Refresh failed - redirect to login</span>
            redirectToLogin();
        }
    }

    <span class="keyword">return</span> response;
}
</code></pre>

                <div class="quiz">
                    <h4>Security Trade-off</h4>
                    <p>Why not just make the access token last 7 days instead of using refresh tokens?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'refresh-token-quiz')">A. Access tokens are sent frequently; if stolen, damage is limited to 15 min</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'refresh-token-quiz')">B. The JWT spec doesn't allow it</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'refresh-token-quiz')">C. Tokens get too big</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'refresh-token-quiz')">D. No real reason, it's just convention</div>
                    </div>
                    <div class="quiz-feedback" id="refresh-token-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="refresh-token-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Access vs Refresh Token Security Model</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="comment"># Access Token:</span>
- Sent with EVERY API request
- Exposed in: network logs, browser history, XSS attacks
- Short-lived (15 min) = limited damage window

<span class="comment"># Refresh Token:</span>
- Only sent to ONE endpoint (/token/refresh/)
- Less exposure surface
- Long-lived (7 days) = user stays logged in
- Can be rotated/blacklisted
</code></pre>
                        <p style="margin-top: 10px;"><strong>The security model:</strong></p>
                        <ul>
                            <li>Access token stolen ‚Üí Attacker has 15 min max</li>
                            <li>Refresh token stolen ‚Üí Worse, but we can blacklist it</li>
                            <li>Both stolen ‚Üí User needs to change password</li>
                        </ul>
                        <p style="margin-top: 10px; color: #888;">It's about minimizing risk exposure - access tokens travel everywhere, so keep them short!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 6: Token Blacklisting -->
        <div class="step" data-step="6">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">6</span>
                <span class="step-title">Logout & Token Blacklisting</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <div class="info-box danger">
                    <strong>Problem:</strong> JWTs can't be truly invalidated!
                    <p style="margin-top: 5px;">
                        Unlike sessions (delete from DB), a valid JWT stays valid until it expires.
                        Solution: Blacklist the token.
                    </p>
                </div>

                <h4>Enable Blacklisting</h4>
<pre><code><span class="comment"># settings.py</span>
INSTALLED_APPS = [
    <span class="comment"># ...</span>
    <span class="string">'rest_framework_simplejwt.token_blacklist'</span>,  <span class="comment"># Add this!</span>
]

<span class="comment"># Then run migrations:</span>
<span class="comment"># python manage.py migrate</span>
<span class="comment"># This creates token_blacklist_* tables</span>
</code></pre>

                <h4>Logout View</h4>
<pre><code><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView
<span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated
<span class="keyword">from</span> rest_framework_simplejwt.tokens <span class="keyword">import</span> RefreshToken

<span class="keyword">class</span> <span class="function">LogoutView</span>(APIView):
    permission_classes = [IsAuthenticated]

    <span class="keyword">def</span> <span class="function">post</span>(self, request):
        <span class="keyword">try</span>:
            refresh_token = request.data[<span class="string">'refresh'</span>]
            token = RefreshToken(refresh_token)
            token.blacklist()  <span class="comment"># Add to blacklist table</span>

            <span class="keyword">return</span> Response({<span class="string">'message'</span>: <span class="string">'Logged out'</span>})
        <span class="keyword">except</span> Exception:
            <span class="keyword">return</span> Response({<span class="string">'error'</span>: <span class="string">'Invalid token'</span>}, status=400)
</code></pre>

                <div class="quiz">
                    <h4>Think About It</h4>
                    <p>We blacklist the REFRESH token. What about the ACCESS token?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'blacklist-quiz')">A. Access token still works until it expires (15 min max)</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'blacklist-quiz')">B. Access token is automatically invalidated</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'blacklist-quiz')">C. We should blacklist access tokens too</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'blacklist-quiz')">D. Access tokens can't be blacklisted</div>
                    </div>
                    <div class="quiz-feedback" id="blacklist-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="blacklist-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #3a2a1a;">
                        <span>‚ö†Ô∏è</span> <strong style="color: #ffa502;">The Logout Limitation of JWT</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="comment"># What happens on logout:</span>

1. Client sends: POST /logout/ { refresh: "xyz..." }
2. Server blacklists refresh token ‚úì
3. User can't get NEW access tokens ‚úì

<span style="color: #ff6b6b;">4. BUT: Current access token still valid for ~15 min!</span>
   <span class="comment">   (It's stateless - server can't invalidate it)</span>
</code></pre>
                        <p style="margin-top: 10px;"><strong>Why not blacklist access tokens too?</strong></p>
                        <ul>
                            <li>Would need DB lookup on EVERY request (defeats "stateless")</li>
                            <li>They expire soon anyway (15 min)</li>
                            <li>Trade-off: Accept the risk for performance</li>
                        </ul>
                        <p style="margin-top: 10px;"><strong>For critical apps:</strong> Use shorter access tokens (5 min) or add token version to user model.</p>
                    </div>
                </div>

                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üí°</span> Alternative: Short-lived tokens + no blacklist
                    </div>
                    <div class="reveal-content">
                        <p>Some systems use 5-minute access tokens and just accept that stolen tokens work for 5 min.</p>
                        <p style="margin-top: 10px;">Trade-off: Simpler (no blacklist DB) vs. Security (longer window)</p>
                        <p style="margin-top: 10px; color: #ffa502;">
                            <strong>For critical actions</strong> (password change, delete account),
                            always re-authenticate or require recent login!
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 7: Testing -->
        <div class="step" data-step="7">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">7</span>
                <span class="step-title">Testing with cURL</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
<pre><code><span class="comment"># 1. Get tokens (login)</span>
curl -X POST http://localhost:8000/api/token/ \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "testpass"}'

<span class="comment"># Response:</span>
<span class="comment"># {"access": "eyJ...", "refresh": "eyJ..."}</span>

<span class="comment"># 2. Access protected endpoint</span>
curl http://localhost:8000/api/protected/ \
  -H "Authorization: Bearer eyJ...access_token..."

<span class="comment"># 3. Refresh token (get new access token)</span>
curl -X POST http://localhost:8000/api/token/refresh/ \
  -H "Content-Type: application/json" \
  -d '{"refresh": "eyJ...refresh_token..."}'

<span class="comment"># 4. Verify a token</span>
curl -X POST http://localhost:8000/api/token/verify/ \
  -H "Content-Type: application/json" \
  -d '{"token": "eyJ...any_token..."}'
</code></pre>

                <div class="info-box tip">
                    <strong>Pro tip:</strong> Use environment variables in your terminal:
<pre style="margin-top: 10px;"><code>ACCESS=eyJ...
curl http://localhost:8000/api/protected/ -H "Authorization: Bearer $ACCESS"</code></pre>
                </div>
            </div>
        </div>

        <!-- Summary -->
        <div class="step" data-step="8">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">‚úì</span>
                <span class="step-title">Summary & Extensions</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <h4>What We Built</h4>
                <table>
                    <tr><th>Component</th><th>Purpose</th></tr>
                    <tr><td><code>settings.py</code></td><td>JWT configuration, lifetimes</td></tr>
                    <tr><td><code>urls.py</code></td><td>Token obtain, refresh, verify endpoints</td></tr>
                    <tr><td>Custom serializer</td><td>Add claims to token payload</td></tr>
                    <tr><td>Permission classes</td><td>Protect views</td></tr>
                    <tr><td>Blacklist</td><td>Enable logout</td></tr>
                </table>

                <h4 style="margin-top: 25px;">Extensions</h4>
                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üöÄ</span> Add custom permission classes
                    </div>
                    <div class="reveal-content">
<pre><code><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission

<span class="keyword">class</span> <span class="function">IsAdmin</span>(BasePermission):
    <span class="keyword">def</span> <span class="function">has_permission</span>(self, request, view):
        <span class="keyword">return</span> request.user.is_staff

<span class="keyword">class</span> <span class="function">IsOwner</span>(BasePermission):
    <span class="keyword">def</span> <span class="function">has_object_permission</span>(self, request, view, obj):
        <span class="keyword">return</span> obj.owner == request.user
</code></pre>
                    </div>
                </div>

                <div class="reveal-box">
                    <div class="reveal-header" onclick="toggleReveal(this)">
                        <span>üìä</span> Store tokens in HTTP-only cookies (more secure)
                    </div>
                    <div class="reveal-content">
<pre><code><span class="comment"># Prevents XSS attacks from stealing tokens</span>
<span class="comment"># pip install djangorestframework-simplejwt[cookies]</span>

SIMPLE_JWT = {
    <span class="string">'AUTH_COOKIE'</span>: <span class="string">'access_token'</span>,
    <span class="string">'AUTH_COOKIE_HTTP_ONLY'</span>: <span class="keyword">True</span>,
    <span class="string">'AUTH_COOKIE_SECURE'</span>: <span class="keyword">True</span>,  <span class="comment"># HTTPS only</span>
}
</code></pre>
                    </div>
                </div>

                <div class="info-box question" style="margin-top: 20px;">
                    <strong>Final Question:</strong> When would you choose JWT over sessions?
                    <p style="margin-top: 10px; color: #aaa;">
                        Think about: Mobile apps, microservices, horizontal scaling, cross-domain auth...
                    </p>
                </div>
            </div>
        </div>

        <!-- Advanced Practice Questions -->
        <div class="step" data-step="9">
            <div class="step-header" onclick="toggleStep(this)">
                <span class="step-number">‚òÖ</span>
                <span class="step-title">Advanced Practice Questions</span>
                <span class="step-toggle">+</span>
            </div>
            <div class="step-content">
                <p style="color: #2ed573; margin-bottom: 25px;">Test your understanding with these medium-to-tough questions covering Design Patterns, OOP, Concurrency, and Python Advanced Concepts - all in the context of JWT token authentication!</p>

                <!-- Design Pattern Question 1: Builder Pattern -->
                <div class="quiz">
                    <h4>Design Pattern: Custom JWT Claims</h4>
                    <p>When building a JWT token, you add claims step-by-step: <code>token['user_id'] = ...; token['email'] = ...; token['roles'] = ...</code>. Which design pattern best describes this construction process?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'builder-pattern-quiz')">A. Builder Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'builder-pattern-quiz')">B. Factory Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'builder-pattern-quiz')">C. Prototype Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'builder-pattern-quiz')">D. Abstract Factory Pattern</div>
                    </div>
                    <div class="quiz-feedback" id="builder-pattern-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="builder-pattern-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Builder Pattern for JWT Token Construction</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>Why Builder Pattern?</strong></p>
                        <ul>
                            <li>Constructs complex objects step-by-step</li>
                            <li>Same construction process can create different representations</li>
                            <li>Separates construction from representation</li>
                        </ul>

                        <h4 style="margin-top: 15px; color: #6eb5ff;">UML Diagram - Builder Pattern for JWT Tokens:</h4>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.85em;">
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       JWTBuilder                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - token: dict                                                    ‚îÇ
‚îÇ - algorithm: str                                                 ‚îÇ
‚îÇ - secret_key: str                                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + set_user_id(user_id: int) -> JWTBuilder                       ‚îÇ
‚îÇ + set_email(email: str) -> JWTBuilder                           ‚îÇ
‚îÇ + set_roles(roles: List[str]) -> JWTBuilder                     ‚îÇ
‚îÇ + set_expiration(exp: datetime) -> JWTBuilder                   ‚îÇ
‚îÇ + set_custom_claim(key: str, value: Any) -> JWTBuilder          ‚îÇ
‚îÇ + build() -> str  (returns encoded JWT)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

<span style="color: #ffd700;">Fluent Interface (method chaining):</span>
token = JWTBuilder()
    .set_user_id(123)
    .set_email("user@example.com")
    .set_roles(["admin", "user"])
    .set_expiration(datetime.now() + timedelta(minutes=15))
    .build()

<span style="color: #2ed573;">Benefits:</span>
- Optional claims (not all tokens need all fields)
- Readable, self-documenting code
- Immutable result after build()
</pre>
                        </div>
<pre><code><span class="comment"># Builder Pattern implementation</span>
<span class="keyword">class</span> <span class="function">JWTBuilder</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, secret_key: str):
        self._claims = {}
        self._secret_key = secret_key

    <span class="keyword">def</span> <span class="function">set_user_id</span>(self, user_id: int) -> <span class="string">'JWTBuilder'</span>:
        self._claims[<span class="string">'user_id'</span>] = user_id
        <span class="keyword">return</span> self  <span class="comment"># Return self for chaining</span>

    <span class="keyword">def</span> <span class="function">set_expiration</span>(self, exp: datetime) -> <span class="string">'JWTBuilder'</span>:
        self._claims[<span class="string">'exp'</span>] = exp.timestamp()
        <span class="keyword">return</span> self

    <span class="keyword">def</span> <span class="function">build</span>(self) -> str:
        <span class="keyword">return</span> jwt.encode(self._claims, self._secret_key, algorithm=<span class="string">'HS256'</span>)
</code></pre>
                    </div>
                </div>

                <!-- Design Pattern Question 2: Factory Pattern -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Design Pattern: Token Types</h4>
                    <p>SimpleJWT creates different token types (AccessToken, RefreshToken) based on input. The creation logic is centralized. Which pattern is this?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'factory-pattern-quiz')">A. Factory Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'factory-pattern-quiz')">B. Builder Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'factory-pattern-quiz')">C. Singleton Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'factory-pattern-quiz')">D. Strategy Pattern</div>
                    </div>
                    <div class="quiz-feedback" id="factory-pattern-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="factory-pattern-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Factory Pattern for Token Creation</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>Why Factory Pattern?</strong></p>
                        <ul>
                            <li>Centralizes object creation logic</li>
                            <li>Client doesn't need to know concrete classes</li>
                            <li>Easy to add new token types</li>
                        </ul>

                        <h4 style="margin-top: 15px; color: #6eb5ff;">UML Diagram - Factory Pattern for Token Types:</h4>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.85em;">
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       TokenFactory                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + create_token(token_type: str, user: User) -> Token            ‚îÇ
‚îÇ + create_token_pair(user: User) -> Tuple[Access, Refresh]       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ creates
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      ¬´abstract¬ª                                  ‚îÇ
‚îÇ                         Token                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + payload: dict                                                  ‚îÇ
‚îÇ + lifetime: timedelta                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + encode() -> str                                                ‚îÇ
‚îÇ + verify() -> bool                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚ñ≥
                              ‚îÇ extends
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ                               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       AccessToken         ‚îÇ   ‚îÇ      RefreshToken         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ lifetime = 15 minutes     ‚îÇ   ‚îÇ lifetime = 7 days         ‚îÇ
‚îÇ token_type = "access"     ‚îÇ   ‚îÇ token_type = "refresh"    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + get_user_id()           ‚îÇ   ‚îÇ + get_user_id()           ‚îÇ
‚îÇ + is_expired()            ‚îÇ   ‚îÇ + blacklist()             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

<span style="color: #ffd700;">Usage:</span>
factory = TokenFactory()
access, refresh = factory.create_token_pair(user)
<span class="comment"># Client doesn't know about AccessToken/RefreshToken classes</span>
</pre>
                        </div>
<pre><code><span class="comment"># Factory Pattern in SimpleJWT</span>
<span class="keyword">class</span> <span class="function">TokenFactory</span>:
    @staticmethod
    <span class="keyword">def</span> <span class="function">create_token</span>(token_type: str, user) -> <span class="string">'Token'</span>:
        <span class="keyword">if</span> token_type == <span class="string">'access'</span>:
            <span class="keyword">return</span> AccessToken.for_user(user)
        <span class="keyword">elif</span> token_type == <span class="string">'refresh'</span>:
            <span class="keyword">return</span> RefreshToken.for_user(user)
        <span class="keyword">else</span>:
            <span class="keyword">raise</span> ValueError(f<span class="string">"Unknown token type: {token_type}"</span>)
</code></pre>
                    </div>
                </div>

                <!-- Design Pattern Question 3: Strategy Pattern -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Design Pattern: Signing Algorithms</h4>
                    <p>JWT can use different signing algorithms (HS256, RS256, ES256). The algorithm can be swapped via <code>SIMPLE_JWT['ALGORITHM']</code>. Which pattern?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-strategy-quiz')">A. Factory Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'jwt-strategy-quiz')">B. Strategy Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-strategy-quiz')">C. Adapter Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'jwt-strategy-quiz')">D. Template Method Pattern</div>
                    </div>
                    <div class="quiz-feedback" id="jwt-strategy-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="jwt-strategy-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Strategy Pattern for JWT Algorithms</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>Why Strategy Pattern?</strong></p>
                        <ul>
                            <li>Defines a family of algorithms (HS256, RS256, ES256)</li>
                            <li>Algorithms are interchangeable at configuration time</li>
                            <li>Same interface (sign/verify) regardless of algorithm</li>
                        </ul>

                        <h4 style="margin-top: 15px; color: #6eb5ff;">UML Diagram - Strategy Pattern for Signing Algorithms:</h4>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.85em;">
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ¬´interface¬ª                                   ‚îÇ
‚îÇ                  SigningAlgorithm                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + sign(payload: bytes, key: bytes) -> bytes                      ‚îÇ
‚îÇ + verify(signature: bytes, payload: bytes, key: bytes) -> bool   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚ñ≥
                              ‚îÇ implements
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                     ‚îÇ                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    HS256      ‚îÇ    ‚îÇ    RS256      ‚îÇ    ‚îÇ    ES256      ‚îÇ
‚îÇ  (Symmetric)  ‚îÇ    ‚îÇ  (Asymmetric) ‚îÇ    ‚îÇ  (Elliptic)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Uses: HMAC    ‚îÇ    ‚îÇ Uses: RSA     ‚îÇ    ‚îÇ Uses: ECDSA   ‚îÇ
‚îÇ Key: shared   ‚îÇ    ‚îÇ Key: pub/priv ‚îÇ    ‚îÇ Key: pub/priv ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + sign()      ‚îÇ    ‚îÇ + sign()      ‚îÇ    ‚îÇ + sign()      ‚îÇ
‚îÇ + verify()    ‚îÇ    ‚îÇ + verify()    ‚îÇ    ‚îÇ + verify()    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    JWTEncoder       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  SigningAlgorithm   ‚îÇ
‚îÇ     (Context)       ‚îÇ uses    ‚îÇ     (Strategy)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ - algorithm: Alg    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   settings.py:
‚îÇ + encode(payload)   ‚îÇ   SIMPLE_JWT = {'ALGORITHM': 'RS256'}
‚îÇ + decode(token)     ‚îÇ   # Strategy swapped via config!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
                        </div>
                        <p style="color: #888;"><strong>Key Insight:</strong> Changing <code>ALGORITHM</code> in settings swaps the entire signing/verification strategy without changing any code.</p>
                    </div>
                </div>

                <!-- Design Pattern Question 4: Adapter Pattern -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Design Pattern: Legacy Auth Integration</h4>
                    <p>Your app uses JWT but needs to integrate with a legacy system that only speaks OAuth 1.0 tokens. You create a wrapper that converts between formats. Which pattern?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'adapter-pattern-quiz')">A. Adapter Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'adapter-pattern-quiz')">B. Bridge Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'adapter-pattern-quiz')">C. Facade Pattern</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'adapter-pattern-quiz')">D. Decorator Pattern</div>
                    </div>
                    <div class="quiz-feedback" id="adapter-pattern-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="adapter-pattern-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Adapter Pattern for Token Format Conversion</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <p><strong>Why Adapter Pattern?</strong></p>
                        <ul>
                            <li>Converts interface of one class to another expected interface</li>
                            <li>Allows incompatible interfaces to work together</li>
                            <li>Doesn't modify existing classes</li>
                        </ul>

                        <h4 style="margin-top: 15px; color: #6eb5ff;">UML Diagram - Adapter for Legacy Auth:</h4>
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.85em;">
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ¬´interface¬ª                                   ‚îÇ
‚îÇ                   JWTAuthenticator                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + authenticate(jwt_token: str) -> User                           ‚îÇ
‚îÇ + get_user_claims(jwt_token: str) -> dict                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚ñ≥
                              ‚îÇ implements
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ                               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   StandardJWTAuth         ‚îÇ   ‚îÇ   LegacyOAuthAdapter      ‚îÇ
‚îÇ   (Native JWT)            ‚îÇ   ‚îÇ   (Adapts OAuth 1.0)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                           ‚îÇ   ‚îÇ - legacy_client: OAuth1   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + authenticate(jwt)       ‚îÇ   ‚îÇ + authenticate(jwt)       ‚îÇ
‚îÇ   ‚Üí decode JWT            ‚îÇ   ‚îÇ   ‚Üí convert to OAuth1     ‚îÇ
‚îÇ   ‚Üí return User           ‚îÇ   ‚îÇ   ‚Üí call legacy_client    ‚îÇ
‚îÇ                           ‚îÇ   ‚îÇ   ‚Üí convert response      ‚îÇ
‚îÇ                           ‚îÇ   ‚îÇ   ‚Üí return User           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                           ‚îÇ
                                           ‚îÇ wraps (composition)
                                           ‚ñº
                                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                ‚îÇ   LegacyOAuth1Client  ‚îÇ
                                ‚îÇ   (incompatible API)  ‚îÇ
                                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                ‚îÇ + validate_token()    ‚îÇ
                                ‚îÇ + get_resource_owner()‚îÇ
                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</pre>
                        </div>
<pre><code><span class="comment"># Adapter Pattern - wrap legacy system</span>
<span class="keyword">class</span> <span class="function">LegacyOAuthAdapter</span>:
    <span class="string">"""Adapts legacy OAuth 1.0 to JWT interface"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, legacy_client: LegacyOAuth1Client):
        self._legacy = legacy_client  <span class="comment"># Composition</span>

    <span class="keyword">def</span> <span class="function">authenticate</span>(self, jwt_token: str) -> User:
        <span class="comment"># Convert JWT claims to OAuth 1.0 format</span>
        claims = jwt.decode(jwt_token, ...)
        oauth_token = self._convert_to_oauth(claims)

        <span class="comment"># Call legacy system</span>
        legacy_user = self._legacy.validate_token(oauth_token)

        <span class="comment"># Convert back to our User format</span>
        <span class="keyword">return</span> self._convert_to_user(legacy_user)
</code></pre>
                    </div>
                </div>

                <!-- OOP Question: Polymorphism -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>OOP: Authentication Class Polymorphism</h4>
                    <p>DRF's <code>DEFAULT_AUTHENTICATION_CLASSES</code> can contain <code>JWTAuthentication</code>, <code>SessionAuthentication</code>, etc. DRF calls <code>authenticate()</code> on each. Which OOP concept enables this?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'polymorphism-quiz')">A. Polymorphism - same method, different implementations</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'polymorphism-quiz')">B. Encapsulation - hiding implementation details</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'polymorphism-quiz')">C. Inheritance - code reuse from parent</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'polymorphism-quiz')">D. Composition - has-a relationship</div>
                    </div>
                    <div class="quiz-feedback" id="polymorphism-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="polymorphism-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Polymorphism in Authentication Classes</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="comment"># DRF's authentication uses polymorphism</span>
<span class="keyword">class</span> <span class="function">BaseAuthentication</span>:
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request):
        <span class="keyword">raise</span> NotImplementedError

<span class="keyword">class</span> <span class="function">JWTAuthentication</span>(BaseAuthentication):
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request):
        token = self._get_token_from_header(request)
        <span class="keyword">return</span> self._decode_and_get_user(token)

<span class="keyword">class</span> <span class="function">SessionAuthentication</span>(BaseAuthentication):
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request):
        <span class="keyword">return</span> request.session.get(<span class="string">'_auth_user_id'</span>)

<span class="comment"># DRF doesn't know/care which implementation - polymorphism!</span>
<span class="keyword">for</span> authenticator <span class="keyword">in</span> authentication_classes:
    result = authenticator.authenticate(request)  <span class="comment"># Same call, different behavior</span>
    <span class="keyword">if</span> result:
        <span class="keyword">return</span> result
</code></pre>
                        <p style="margin-top: 10px;"><strong>Polymorphism enables:</strong></p>
                        <ul>
                            <li>Treating different auth methods uniformly</li>
                            <li>Easy to add new authentication methods</li>
                            <li>Open/Closed Principle: open for extension, closed for modification</li>
                        </ul>
                    </div>
                </div>

                <!-- OOP Question: Static Methods -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>OOP: Token's @classmethod</h4>
                    <p>SimpleJWT uses <code>RefreshToken.for_user(user)</code> to create tokens. This is a <code>@classmethod</code>. Why not <code>@staticmethod</code> or regular instance method?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'classmethod-quiz')">A. No reason, they're interchangeable</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'classmethod-quiz')">B. @classmethod receives 'cls' - can create instances and access class attributes</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'classmethod-quiz')">C. @staticmethod is deprecated</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'classmethod-quiz')">D. Instance methods can't create new instances</div>
                    </div>
                    <div class="quiz-feedback" id="classmethod-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="classmethod-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">@classmethod vs @staticmethod</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="keyword">class</span> <span class="function">RefreshToken</span>(Token):
    token_type = <span class="string">'refresh'</span>
    lifetime = timedelta(days=7)

    @classmethod
    <span class="keyword">def</span> <span class="function">for_user</span>(cls, user):
        <span class="string">"""Factory method using @classmethod"""</span>
        token = cls()  <span class="comment"># ‚Üê Uses cls to create instance (works with subclasses!)</span>
        token[<span class="string">'user_id'</span>] = user.id
        token.set_exp(lifetime=cls.lifetime)  <span class="comment"># ‚Üê Access class attribute</span>
        <span class="keyword">return</span> token

<span class="comment"># Why @classmethod works with inheritance:</span>
<span class="keyword">class</span> <span class="function">CustomRefreshToken</span>(RefreshToken):
    lifetime = timedelta(days=30)  <span class="comment"># Override</span>

token = CustomRefreshToken.for_user(user)
<span class="comment"># cls = CustomRefreshToken, uses 30 days!</span>

<span class="comment"># Comparison:</span>
<span class="comment"># @staticmethod: No access to cls or self - just a regular function in class namespace</span>
<span class="comment"># @classmethod: Receives cls - can create instances, access class vars, works with inheritance</span>
<span class="comment"># instance method: Receives self - needs an existing instance</span>
</code></pre>
                    </div>
                </div>

                <!-- Concurrency Question: Async Token Verification -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Concurrency: Async Token Verification</h4>
                    <p>You need to verify JWT tokens in an async Django view. The verification involves a database call to check blacklist. Which approach is correct?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'async-quiz')">A. Use regular sync code - Django handles it automatically</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'async-quiz')">B. Use async def view and await database calls with async ORM</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'async-quiz')">C. Use threading.Thread to run verification in background</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'async-quiz')">D. JWT verification can't be async</div>
                    </div>
                    <div class="quiz-feedback" id="async-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="async-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Async I/O for Token Verification</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="comment"># Django 4.1+ supports async views and async ORM</span>

<span class="comment"># ‚ùå Sync approach - blocks the event loop</span>
<span class="keyword">def</span> <span class="function">verify_token_sync</span>(request):
    token = get_token(request)
    is_blacklisted = BlacklistedToken.objects.filter(token=token).exists()
    <span class="keyword">return</span> <span class="keyword">not</span> is_blacklisted

<span class="comment"># ‚úÖ Async approach - non-blocking</span>
<span class="keyword">async def</span> <span class="function">verify_token_async</span>(request):
    token = get_token(request)
    <span class="comment"># Use async ORM (Django 4.1+)</span>
    is_blacklisted = <span class="keyword">await</span> BlacklistedToken.objects.filter(token=token).aexists()
    <span class="keyword">return</span> <span class="keyword">not</span> is_blacklisted

<span class="comment"># Async view with authentication</span>
<span class="keyword">async def</span> <span class="function">protected_view</span>(request):
    <span class="keyword">if not await</span> verify_token_async(request):
        <span class="keyword">return</span> JsonResponse({<span class="string">'error'</span>: <span class="string">'Invalid token'</span>}, status=401)

    <span class="comment"># Async database query</span>
    user = <span class="keyword">await</span> User.objects.aget(id=request.user_id)
    <span class="keyword">return</span> JsonResponse({<span class="string">'user'</span>: user.username})
</code></pre>
                        <p style="margin-top: 10px;"><strong>Why async matters for auth:</strong></p>
                        <ul>
                            <li>Token verification happens on EVERY request</li>
                            <li>Sync DB calls block the entire event loop</li>
                            <li>Async allows handling more concurrent requests</li>
                        </ul>
                    </div>
                </div>

                <!-- Concurrency Question: Deadlock -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Concurrency: Token Refresh Deadlock</h4>
                    <p>Thread A holds lock on user_tokens, waits for blacklist_lock. Thread B holds blacklist_lock, waits for user_tokens. This is called:</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'deadlock-quiz')">A. Race condition</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'deadlock-quiz')">B. Deadlock</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'deadlock-quiz')">C. Starvation</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'deadlock-quiz')">D. Livelock</div>
                    </div>
                    <div class="quiz-feedback" id="deadlock-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="deadlock-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #3a1a1a;">
                        <span>‚ö†Ô∏è</span> <strong style="color: #ff4757;">Deadlock - Circular Wait</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
                        <div class="diagram" style="padding: 15px; margin: 10px 0;">
<pre style="color: #eee; margin: 0; font-size: 0.85em;">
<span style="color: #ff6b6b;">Deadlock Scenario:</span>

Thread A (refresh_token)          Thread B (blacklist_token)
    ‚îÇ                                  ‚îÇ
    ‚îÇ acquire(user_tokens_lock) ‚úì      ‚îÇ
    ‚îÇ                                  ‚îÇ acquire(blacklist_lock) ‚úì
    ‚îÇ                                  ‚îÇ
    ‚îÇ acquire(blacklist_lock)          ‚îÇ acquire(user_tokens_lock)
    ‚îÇ     ‚Üì BLOCKED                    ‚îÇ     ‚Üì BLOCKED
    ‚îÇ     waiting for B                ‚îÇ     waiting for A
    ‚îÇ                                  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DEADLOCK! ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

<span style="color: #2ed573;">Four conditions for deadlock (all must be true):</span>
1. Mutual Exclusion: Resources can't be shared
2. Hold and Wait: Holding one, waiting for another
3. No Preemption: Can't force release
4. Circular Wait: A‚ÜíB‚ÜíA

<span style="color: #6eb5ff;">Solutions:</span>
1. Lock ordering: Always acquire locks in same order (alphabetically)
2. Lock timeout: with lock.acquire(timeout=5)
3. Single lock: Combine into one lock if possible
</pre>
                        </div>
<pre><code><span class="comment"># ‚ùå Deadlock prone - inconsistent lock order</span>
<span class="keyword">def</span> <span class="function">refresh_token</span>():
    <span class="keyword">with</span> user_tokens_lock:
        <span class="keyword">with</span> blacklist_lock:  <span class="comment"># Order: user ‚Üí blacklist</span>
            ...

<span class="keyword">def</span> <span class="function">blacklist_token</span>():
    <span class="keyword">with</span> blacklist_lock:
        <span class="keyword">with</span> user_tokens_lock:  <span class="comment"># Order: blacklist ‚Üí user (OPPOSITE!)</span>
            ...

<span class="comment"># ‚úÖ Fixed - consistent lock order</span>
<span class="keyword">def</span> <span class="function">blacklist_token</span>():
    <span class="keyword">with</span> user_tokens_lock:  <span class="comment"># Same order as refresh_token</span>
        <span class="keyword">with</span> blacklist_lock:
            ...
</code></pre>
                    </div>
                </div>

                <!-- Python Advanced: Futures -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Concurrency: Parallel Token Validation</h4>
                    <p>You need to validate 100 tokens concurrently. Which approach uses the Executor pattern correctly?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'futures-quiz')">A. Create 100 threads manually with threading.Thread</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'futures-quiz')">B. Use ThreadPoolExecutor.map() or submit() with Future objects</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'futures-quiz')">C. Use multiprocessing.Pool for I/O-bound tasks</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'futures-quiz')">D. Sequential for loop is fine for 100 items</div>
                    </div>
                    <div class="quiz-feedback" id="futures-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="futures-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">ThreadPoolExecutor and Futures</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed

<span class="keyword">def</span> <span class="function">validate_token</span>(token: str) -> bool:
    <span class="string">"""I/O-bound: DB lookup for blacklist"""</span>
    <span class="keyword">return not</span> BlacklistedToken.objects.filter(token=token).exists()

tokens = [<span class="string">'token1'</span>, <span class="string">'token2'</span>, ...]  <span class="comment"># 100 tokens</span>

<span class="comment"># ‚úÖ Using ThreadPoolExecutor</span>
<span class="keyword">with</span> ThreadPoolExecutor(max_workers=20) <span class="keyword">as</span> executor:
    <span class="comment"># Method 1: map() - ordered results</span>
    results = list(executor.map(validate_token, tokens))

    <span class="comment"># Method 2: submit() + as_completed - unordered, first-finished first</span>
    futures = {executor.submit(validate_token, t): t <span class="keyword">for</span> t <span class="keyword">in</span> tokens}
    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):
        token = futures[future]
        <span class="keyword">try</span>:
            is_valid = future.result()
            print(f<span class="string">"{token}: {'valid' if is_valid else 'blacklisted'}"</span>)
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            print(f<span class="string">"{token}: error - {e}"</span>)

<span class="comment"># Why ThreadPool over ProcessPool?</span>
<span class="comment"># - Token validation is I/O-bound (DB calls)</span>
<span class="comment"># - Threads share memory (no serialization overhead)</span>
<span class="comment"># - ProcessPool better for CPU-bound tasks</span>
</code></pre>
                    </div>
                </div>

                <!-- Python Advanced: Collections -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Python Advanced: Token Cache</h4>
                    <p>You need a cache that automatically removes the least-recently-used (LRU) tokens when full. Which collection is purpose-built for this?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'collections-quiz')">A. dict - standard dictionary</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'collections-quiz')">B. OrderedDict - remembers insertion order</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'collections-quiz')">C. functools.lru_cache or manual LRU with OrderedDict</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'collections-quiz')">D. defaultdict - provides default values</div>
                    </div>
                    <div class="quiz-feedback" id="collections-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="collections-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">LRU Cache for Token Validation</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache
<span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict

<span class="comment"># Method 1: @lru_cache decorator (simplest)</span>
@lru_cache(maxsize=1000)
<span class="keyword">def</span> <span class="function">decode_token</span>(token: str) -> dict:
    <span class="string">"""Cache decoded tokens - expensive crypto operation"""</span>
    <span class="keyword">return</span> jwt.decode(token, SECRET_KEY, algorithms=[<span class="string">'HS256'</span>])

<span class="comment"># Cache stats</span>
print(decode_token.cache_info())
<span class="comment"># CacheInfo(hits=950, misses=50, maxsize=1000, currsize=50)</span>

<span class="comment"># Method 2: Manual LRU with OrderedDict (more control)</span>
<span class="keyword">class</span> <span class="function">TokenCache</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, maxsize: int = 1000):
        self._cache = OrderedDict()
        self._maxsize = maxsize

    <span class="keyword">def</span> <span class="function">get</span>(self, token: str) -> dict | <span class="keyword">None</span>:
        <span class="keyword">if</span> token <span class="keyword">in</span> self._cache:
            self._cache.move_to_end(token)  <span class="comment"># Mark as recently used</span>
            <span class="keyword">return</span> self._cache[token]
        <span class="keyword">return None</span>

    <span class="keyword">def</span> <span class="function">set</span>(self, token: str, payload: dict):
        <span class="keyword">if</span> len(self._cache) >= self._maxsize:
            self._cache.popitem(last=<span class="keyword">False</span>)  <span class="comment"># Remove LRU (first item)</span>
        self._cache[token] = payload
</code></pre>
                        <p style="margin-top: 10px;"><strong>Why cache tokens?</strong></p>
                        <ul>
                            <li>JWT decoding involves crypto (relatively expensive)</li>
                            <li>Same token validated multiple times per session</li>
                            <li>LRU ensures fresh tokens stay, stale ones evicted</li>
                        </ul>
                    </div>
                </div>

                <!-- Python Advanced: Type Annotations -->
                <div class="quiz" style="margin-top: 25px;">
                    <h4>Python Advanced: Protocol for Auth Classes</h4>
                    <p>You want to type-hint that a function accepts any object with an <code>authenticate(request)</code> method, without requiring inheritance. Which typing construct?</p>
                    <div class="quiz-options">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'protocol-quiz')">A. ABC with @abstractmethod</div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 'protocol-quiz')">B. typing.Protocol - structural subtyping</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'protocol-quiz')">C. Union of all known auth classes</div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 'protocol-quiz')">D. TypeVar with bound</div>
                    </div>
                    <div class="quiz-feedback" id="protocol-quiz-feedback"></div>
                </div>

                <div class="reveal-box" id="protocol-explanation" style="display: none;">
                    <div class="reveal-header" onclick="toggleReveal(this)" style="background: #1a3a2a;">
                        <span>‚úì</span> <strong style="color: #2ed573;">Protocol - Structural Subtyping (Duck Typing with Types)</strong>
                    </div>
                    <div class="reveal-content" style="display: block;">
<pre><code><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol, Optional, Tuple
<span class="keyword">from</span> django.http <span class="keyword">import</span> HttpRequest

<span class="comment"># Protocol defines required methods - no inheritance needed!</span>
<span class="keyword">class</span> <span class="function">Authenticator</span>(Protocol):
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request: HttpRequest) -> Optional[Tuple[User, str]]:
        ...

<span class="comment"># Any class with this method signature satisfies the Protocol</span>
<span class="keyword">class</span> <span class="function">JWTAuth</span>:  <span class="comment"># No inheritance!</span>
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request: HttpRequest) -> Optional[Tuple[User, str]]:
        <span class="keyword">return</span> self._decode_jwt(request)

<span class="keyword">class</span> <span class="function">APIKeyAuth</span>:  <span class="comment"># No inheritance!</span>
    <span class="keyword">def</span> <span class="function">authenticate</span>(self, request: HttpRequest) -> Optional[Tuple[User, str]]:
        <span class="keyword">return</span> self._check_api_key(request)

<span class="comment"># Function accepts ANY Authenticator (structural typing)</span>
<span class="keyword">def</span> <span class="function">authenticate_request</span>(auth: Authenticator, request: HttpRequest):
    <span class="keyword">return</span> auth.authenticate(request)

<span class="comment"># Both work! Type checker validates based on STRUCTURE, not inheritance</span>
authenticate_request(JWTAuth(), request)     <span class="comment"># ‚úì</span>
authenticate_request(APIKeyAuth(), request)  <span class="comment"># ‚úì</span>
</code></pre>
                        <p style="margin-top: 10px;"><strong>Protocol vs ABC:</strong></p>
                        <ul>
                            <li><strong>ABC:</strong> Nominal typing - must explicitly inherit</li>
                            <li><strong>Protocol:</strong> Structural typing - just needs matching methods (duck typing with type safety)</li>
                        </ul>
                    </div>
                </div>

            </div>
        </div>

        <div class="nav-links">
            <a href="../session-auth-guide/index.html">‚Üê Session Auth Guide</a>
            <a href="../oauth2-auth-guide/index.html">Next: OAuth2 Guide ‚Üí</a>
        </div>
    </div>

    <script>
        function toggleStep(header) {
            const step = header.parentElement;
            const wasActive = step.classList.contains('active');
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            if (!wasActive) step.classList.add('active');
            updateProgress();
        }

        function toggleReveal(header) {
            header.parentElement.classList.toggle('open');
        }

        function checkAnswer(option, isCorrect, quizId) {
            const quiz = option.closest('.quiz');
            const options = quiz.querySelectorAll('.quiz-option');
            const feedback = quiz.querySelector('.quiz-feedback');

            options.forEach(opt => {
                opt.classList.remove('correct', 'wrong');
                opt.style.pointerEvents = 'none';
            });

            if (isCorrect) {
                option.classList.add('correct');
                feedback.style.display = 'block';
                feedback.style.background = '#1a3a2a';
                feedback.style.color = '#2ed573';
                feedback.textContent = '‚úì Correct!';
            } else {
                option.classList.add('wrong');
                options.forEach(opt => {
                    if (opt.onclick.toString().includes('true')) opt.classList.add('correct');
                });
                feedback.style.display = 'block';
                feedback.style.background = '#3a1a1a';
                feedback.style.color = '#ff4757';
                feedback.textContent = '‚úó Not quite. See the correct answer.';
            }

            // Show explanation regardless of correct/incorrect answer
            if (quizId) {
                // Try both patterns: -quiz to -explanation and -recall to -recall-explanation
                let explanation = document.getElementById(quizId.replace('-quiz', '-explanation'));
                if (!explanation) {
                    explanation = document.getElementById(quizId.replace('-recall', '-recall-explanation'));
                }
                if (explanation) {
                    explanation.style.display = 'block';
                    explanation.classList.add('open');
                }
            }
        }

        function updateProgress() {
            const steps = document.querySelectorAll('.step');
            const activeIndex = Array.from(steps).findIndex(s => s.classList.contains('active'));
            document.getElementById('progress').style.width = ((activeIndex + 1) / steps.length) * 100 + '%';
        }

        updateProgress();
    </script>
</body>
</html>
