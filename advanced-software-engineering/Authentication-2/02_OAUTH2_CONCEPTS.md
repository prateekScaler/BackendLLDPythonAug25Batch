# OAuth 2.0 Concepts

## What is OAuth 2.0?

OAuth 2.0 is an **authorization framework** that enables applications to obtain limited access to user accounts on third-party services. It's the protocol behind "Login with Google/Facebook/GitHub".

## The Problem OAuth Solves

```
WITHOUT OAUTH (The Bad Old Days)
════════════════════════════════

You want App X to access your Google Photos.

Old way:
1. App X asks for your Google password
2. You give App X your password (yikes!)
3. App X logs into Google AS YOU
4. App X has FULL access to your account

Problems:
❌ App X has your password
❌ App X can do ANYTHING as you
❌ To revoke access, you must change password
❌ No granular permissions
```

```
WITH OAUTH 2.0 (The Right Way)
══════════════════════════════

You want App X to access your Google Photos.

OAuth way:
1. App X redirects you to Google
2. Google asks: "Allow App X to view your photos?"
3. You click "Allow"
4. Google gives App X a LIMITED token
5. App X can ONLY view photos (nothing else)

Benefits:
✅ App X NEVER sees your password
✅ App X has LIMITED access (photos only)
✅ Revoke access anytime without changing password
✅ Granular permissions (scopes)
```

## Key Terminology

| Term | Description | Real-World Example |
|------|-------------|-------------------|
| **Resource Owner** | The user who owns the data | You (own your Google photos) |
| **Client** | App wanting access | A photo printing app |
| **Authorization Server** | Issues tokens after user consent | Google's OAuth server |
| **Resource Server** | Holds the protected data | Google Photos API |
| **Access Token** | Key to access resources | The token given to the app |
| **Refresh Token** | Used to get new access tokens | Long-lived token for renewal |
| **Scope** | What permissions are granted | `photos.readonly`, `email` |

## OAuth 2.0 Flows (Grant Types)

### 1. Authorization Code Flow (Most Common)
**Use for:** Server-side web apps, mobile apps

```
USER          CLIENT (App)      AUTH SERVER       RESOURCE SERVER
 │                 │                 │                   │
 │── Click login ─►│                 │                   │
 │                 │                 │                   │
 │◄── Redirect to Auth Server ──────►│                   │
 │                 │                 │                   │
 │── Login + Consent ───────────────►│                   │
 │                 │                 │                   │
 │◄── Redirect with AUTH CODE ───────│                   │
 │                 │                 │                   │
 │── AUTH CODE ───►│                 │                   │
 │                 │── Exchange code for token ─────────►│
 │                 │◄── ACCESS TOKEN + REFRESH TOKEN ───│
 │                 │                 │                   │
 │                 │── API request + ACCESS TOKEN ─────────────────►│
 │                 │◄── Protected resource ─────────────────────────│
 │◄── Show data ───│                 │                   │
```

### 2. Client Credentials Flow
**Use for:** Server-to-server (no user involved)

```
CLIENT (Backend)     AUTH SERVER       RESOURCE SERVER
     │                    │                   │
     │── client_id + ────►│                   │
     │   client_secret    │                   │
     │◄── ACCESS TOKEN ───│                   │
     │                    │                   │
     │── API request + token ────────────────►│
     │◄── Data ──────────────────────────────│
```

### 3. PKCE Flow (Authorization Code + PKCE)
**Use for:** Mobile apps, SPAs (public clients)

```
Same as Authorization Code, but with:
- code_verifier: Random string generated by client
- code_challenge: SHA256 hash of code_verifier

This prevents authorization code interception attacks.
```

## Scopes: Granular Permissions

```
OAUTH SCOPES EXAMPLE
════════════════════

App requests: scope=email photos.readonly

What user sees:
┌─────────────────────────────────────┐
│  Photo Print App wants to:          │
│                                     │
│  ✓ View your email address          │
│  ✓ View your photos                 │
│                                     │
│  [Allow]         [Deny]             │
└─────────────────────────────────────┘

What app can do:
✅ Read email
✅ View photos
❌ Delete photos
❌ Access Drive
❌ Send emails
```

## Access Token vs Refresh Token

| Aspect | Access Token | Refresh Token |
|--------|--------------|---------------|
| **Purpose** | Access APIs | Get new access tokens |
| **Lifetime** | Short (15-60 min) | Long (days to months) |
| **Sent to** | Resource server | Authorization server only |
| **Storage** | Memory (if possible) | Secure storage |
| **If stolen** | Limited damage (expires) | Can get new access tokens |

## Token Refresh Flow

```
ACCESS TOKEN EXPIRED
════════════════════

Client              Auth Server
  │                      │
  │── API Request ──────►│  (Access token expired)
  │◄── 401 Unauthorized ─│
  │                      │
  │── Refresh Token ────►│
  │◄── New Access Token ─│
  │                      │
  │── API Request ──────►│  (New access token)
  │◄── 200 OK ───────────│
```

## Common OAuth Providers

| Provider | Authorization Endpoint | Token Endpoint |
|----------|----------------------|----------------|
| Google | accounts.google.com/o/oauth2/v2/auth | oauth2.googleapis.com/token |
| GitHub | github.com/login/oauth/authorize | github.com/login/oauth/access_token |
| Facebook | facebook.com/v12.0/dialog/oauth | graph.facebook.com/v12.0/oauth/access_token |

## Security Best Practices

1. **Always use HTTPS**
2. **Validate redirect_uri** - Prevent open redirect attacks
3. **Use state parameter** - Prevent CSRF attacks
4. **Store tokens securely** - Never in localStorage for sensitive apps
5. **Use PKCE for public clients** - Mobile apps, SPAs
6. **Implement token rotation** - New refresh token on each use
7. **Validate all tokens server-side** - Never trust client validation

## OAuth vs Authentication

```
IMPORTANT DISTINCTION
═════════════════════

OAuth 2.0 is for AUTHORIZATION, not AUTHENTICATION!

OAuth answers: "What can this app access?"
NOT: "Who is this user?"

For authentication, use:
- OpenID Connect (OIDC) - built on top of OAuth 2.0
- OIDC adds an ID Token with user identity
```

## Real-World Example: "Login with Google"

```python
# 1. Redirect user to Google
redirect_url = (
    "https://accounts.google.com/o/oauth2/v2/auth?"
    "client_id=YOUR_CLIENT_ID&"
    "redirect_uri=https://yourapp.com/callback&"
    "response_type=code&"
    "scope=email profile&"
    "state=random_csrf_token"
)

# 2. Google redirects back with code
# https://yourapp.com/callback?code=AUTH_CODE&state=random_csrf_token

# 3. Exchange code for tokens
response = requests.post(
    "https://oauth2.googleapis.com/token",
    data={
        "client_id": "YOUR_CLIENT_ID",
        "client_secret": "YOUR_CLIENT_SECRET",
        "code": "AUTH_CODE",
        "grant_type": "authorization_code",
        "redirect_uri": "https://yourapp.com/callback"
    }
)
tokens = response.json()
# {"access_token": "...", "refresh_token": "...", "id_token": "..."}

# 4. Use access token to get user info
user_info = requests.get(
    "https://www.googleapis.com/oauth2/v2/userinfo",
    headers={"Authorization": f"Bearer {tokens['access_token']}"}
).json()
# {"email": "user@gmail.com", "name": "John Doe", ...}
```
