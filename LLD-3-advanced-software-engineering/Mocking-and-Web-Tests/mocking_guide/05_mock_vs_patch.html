<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mock vs Patch - Mocking Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="navbar-content">
            <a href="index.html" class="navbar-brand">ğŸ­ Mocking Guide</a>
            <div class="navbar-nav">
                <a href="index.html" class="nav-btn">Home</a>
                <a href="09_cheatsheet.html" class="nav-btn">Cheat Sheet</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <header class="page-header">
            <div class="page-icon">âš–ï¸</div>
            <h1>Mock vs Patch</h1>
            <p class="subtitle">When to use which approach</p>
        </header>

        <div class="section">
            <h2>The Key Question</h2>

            <div class="info-box">
                <strong>ğŸ’¡ Ask yourself: "Can I pass the fake object into my code?"</strong>
                <ul>
                    <li><strong>YES</strong> â†’ Use <code>Mock()</code> directly (simpler)</li>
                    <li><strong>NO</strong> â†’ Use <code>patch()</code> to intercept (necessary)</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Decision Table</h2>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Scenario</th>
                        <th>Use Mock</th>
                        <th>Use patch</th>
                    </tr>
                    <tr>
                        <td>Dependency <strong>injected</strong> via constructor/method</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>Dependency <strong>created inside</strong> the function</td>
                        <td>âŒ</td>
                        <td>âœ…</td>
                    </tr>
                    <tr>
                        <td>You <strong>control</strong> how object is passed</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>Code uses hardcoded <code>ClassName()</code></td>
                        <td>âŒ</td>
                        <td>âœ…</td>
                    </tr>
                    <tr>
                        <td>Testing standalone function with imports</td>
                        <td>âŒ</td>
                        <td>âœ…</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Example 1: Use Mock (Dependency Injection)</h2>
            <p>When code is designed for testability with dependency injection:</p>

<pre><code class="language-python"># GOOD CODE DESIGN - Dependency is injected
class OrderService:
    def __init__(self, payment_gateway):  # Dependency passed in!
        self.gateway = payment_gateway

    def checkout(self, amount):
        return self.gateway.charge(amount)

# TEST - Just pass a mock directly!
def test_checkout_with_mock():
    # Create mock
    mock_gateway = Mock()
    mock_gateway.charge.return_value = {"status": "success"}

    # Inject mock directly - no patch needed!
    service = OrderService(payment_gateway=mock_gateway)

    # Test
    result = service.checkout(100)

    # Assert
    assert result["status"] == "success"
    mock_gateway.charge.assert_called_once_with(100)</code></pre>

            <div class="success-box">
                <strong>âœ… Why Mock works here:</strong>
                <p>You control how <code>payment_gateway</code> is provided, so you just pass your mock directly. Simple and clean!</p>
            </div>
        </div>

        <div class="section">
            <h2>Example 2: Use patch (Hardcoded Dependency)</h2>
            <p>When code creates its own dependencies internally:</p>

<pre><code class="language-python"># NOT IDEAL CODE - Dependency created inside
class OrderService:
    def checkout(self, amount):
        gateway = PaymentGateway()  # Created inside! Can't inject!
        return gateway.charge(amount)

# TEST - Must use patch to intercept
@patch('order_service.PaymentGateway')
def test_checkout_with_patch(mock_gateway_class):
    # Configure the mock instance that will be created
    mock_instance = mock_gateway_class.return_value
    mock_instance.charge.return_value = {"status": "success"}

    # Test - patch intercepts PaymentGateway() call
    service = OrderService()
    result = service.checkout(100)

    # Assert
    assert result["status"] == "success"
    mock_instance.charge.assert_called_once_with(100)</code></pre>

            <div class="warning-box">
                <strong>âš ï¸ Why patch is needed:</strong>
                <p>You can't pass a mock because the code creates <code>PaymentGateway()</code> internally. <code>patch</code> intercepts that creation.</p>
            </div>
        </div>

        <div class="section">
            <h2>Visual Comparison</h2>

            <div class="diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MOCK (Direct Injection)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   # Your code (well-designed)                                   â”‚
â”‚   class Service:                                                â”‚
â”‚       def __init__(self, dependency):  â† You pass it in        â”‚
â”‚           self.dep = dependency                                 â”‚
â”‚                                                                 â”‚
â”‚   # Your test                                                   â”‚
â”‚   mock = Mock()                                                 â”‚
â”‚   service = Service(mock)  â† Direct injection, simple!         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PATCH (Intercept Creation)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   # Your code (hardcoded dependency)                            â”‚
â”‚   class Service:                                                â”‚
â”‚       def do_something(self):                                   â”‚
â”‚           dep = Dependency()  â† Created inside, can't inject   â”‚
â”‚           return dep.call()                                     â”‚
â”‚                                                                 â”‚
â”‚   # Your test                                                   â”‚
â”‚   @patch('module.Dependency')  â† Intercept at module level     â”‚
â”‚   def test(mock_class):                                         â”‚
â”‚       mock_class.return_value.call.return_value = "mocked"     â”‚
â”‚       service = Service()                                       â”‚
â”‚       result = service.do_something()  â† patch intercepts      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
            </div>
        </div>

        <div class="section">
            <h2>Quick Reference</h2>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Aspect</th>
                        <th>Mock()</th>
                        <th>patch()</th>
                    </tr>
                    <tr>
                        <td><strong>What it does</strong></td>
                        <td>Creates a fake object</td>
                        <td>Replaces a real object temporarily</td>
                    </tr>
                    <tr>
                        <td><strong>When to use</strong></td>
                        <td>Dependency injection</td>
                        <td>Hardcoded dependencies</td>
                    </tr>
                    <tr>
                        <td><strong>Scope</strong></td>
                        <td>Manual - you control lifecycle</td>
                        <td>Automatic - restored after test</td>
                    </tr>
                    <tr>
                        <td><strong>Complexity</strong></td>
                        <td>Simple</td>
                        <td>More complex (path strings)</td>
                    </tr>
                    <tr>
                        <td><strong>Code design</strong></td>
                        <td>Works with good design (DI)</td>
                        <td>Works with any design</td>
                    </tr>
                    <tr>
                        <td><strong>Typical pattern</strong></td>
                        <td><code>service = Service(mock)</code></td>
                        <td><code>@patch('module.Class')</code></td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Real-World Analogy</h2>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Technique</th>
                        <th>Analogy</th>
                    </tr>
                    <tr>
                        <td><strong>Mock</strong></td>
                        <td>ğŸ”Œ Car has a socket for the engine. You bring your test engine and plug it in.</td>
                    </tr>
                    <tr>
                        <td><strong>patch</strong></td>
                        <td>ğŸ”§ Engine is welded inside the car. You secretly swap it at runtime, then swap it back.</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="section">
            <h2>Best Practice</h2>

            <div class="success-box">
                <strong>âœ… Prefer Mock over patch when possible</strong>
                <p>If you find yourself using <code>patch</code> a lot, consider refactoring your code to use dependency injection. It makes testing simpler and code more maintainable!</p>
            </div>

<pre><code class="language-python"># BETTER: Refactor for dependency injection
class OrderService:
    def __init__(self, payment_gateway=None, email_service=None):
        self.payment = payment_gateway or PaymentGateway()
        self.email = email_service or EmailService()

# Now tests are simple:
def test_order():
    service = OrderService(
        payment_gateway=Mock(),
        email_service=Mock()
    )
    # No patch needed!</code></pre>
        </div>

        <!-- Quiz -->
        <div class="quiz-container">
            <div class="quiz-title">ğŸ§  Quiz: Test Your Understanding</div>
            <p style="margin-bottom: 1rem;">When should you prefer Mock over patch?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    A) When testing legacy code with hardcoded dependencies
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, true)">
                    B) When your code uses dependency injection
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    C) When you need to mock magic methods
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    D) When testing async code
                </div>
            </div>
            <div class="quiz-feedback" id="quiz-feedback"></div>
        </div>

        <!-- Navigation -->
        <div class="page-nav">
            <a href="04_patching.html">â† Previous: Patching</a>
            <a href="06_side_effect.html">Next: side_effect â†’</a>
        </div>

        <footer>
            <p>Page 5 of 9 â€¢ Mocking in Python Guide</p>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function checkAnswer(element, isCorrect) {
            const options = document.querySelectorAll('.quiz-option');
            const feedback = document.getElementById('quiz-feedback');

            options.forEach(opt => {
                opt.classList.add('disabled');
                if (opt.onclick.toString().includes('true')) {
                    opt.classList.add('correct');
                }
            });

            if (isCorrect) {
                element.classList.add('correct');
                feedback.className = 'quiz-feedback show correct';
                feedback.innerHTML = 'âœ… Correct! When code uses dependency injection, you can simply pass mocks directly - no patching needed.';
            } else {
                element.classList.add('incorrect');
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = 'âŒ Not quite. Mock is preferred when you can inject dependencies, making tests simpler and cleaner.';
            }
        }
    </script>
</body>
</html>
