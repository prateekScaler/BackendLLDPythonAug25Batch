<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Security - Auth Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="navbar-content">
            <a href="index.html" class="navbar-brand">ğŸ” Auth Guide</a>
            <div class="navbar-nav">
                <a href="index.html" class="nav-btn">Home</a>
                <a href="07_cheatsheet.html" class="nav-btn">Cheat Sheet</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <header class="page-header">
            <div class="page-icon">ğŸ”‘</div>
            <h1>Password Security</h1>
            <p class="subtitle">The journey from plaintext to BCrypt</p>
        </header>

        <!-- Era 1: Plaintext -->
        <div class="section">
            <h2>Era 1: Plaintext Storage (The Dark Ages)</h2>

            <p>In the early days of computing, passwords were stored exactly as users typed them:</p>

            <pre><code class="language-python"># How it worked in the 1960s-1980s
def register(username, password):
    db.execute(
        "INSERT INTO users VALUES (?, ?)",
        (username, password)  # Stored as-is!
    )</code></pre>

            <div class="diagram">
<pre>
Database dump:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ username    â”‚ password         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ alice       â”‚ ilovecats        â”‚
â”‚ bob         â”‚ password123      â”‚
â”‚ ceo         â”‚ company2024!     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â˜ ï¸ Anyone with DB access sees ALL passwords!
</pre>
            </div>

            <h3>Ways Plaintext Can Be Exploited</h3>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Attack Vector</th>
                        <th>How It Works</th>
                        <th>Real Example</th>
                    </tr>
                    <tr>
                        <td><strong>Database Breach</strong></td>
                        <td>Attacker gains DB access (SQL injection, stolen backup)</td>
                        <td>RockYou 2009 - 32M passwords leaked</td>
                    </tr>
                    <tr>
                        <td><strong>Insider Threat</strong></td>
                        <td>Employees/DBAs can read all passwords</td>
                        <td>Facebook 2019 - 20,000 employees had access</td>
                    </tr>
                    <tr>
                        <td><strong>Log Files</strong></td>
                        <td>Passwords accidentally logged in plaintext</td>
                        <td>Twitter 2018 - Passwords in internal logs</td>
                    </tr>
                    <tr>
                        <td><strong>Backup Theft</strong></td>
                        <td>Database backups stolen/left unsecured</td>
                        <td>Common in ransomware attacks</td>
                    </tr>
                    <tr>
                        <td><strong>Shoulder Surfing</strong></td>
                        <td>Admin viewing passwords on screen</td>
                        <td>Support staff reading passwords</td>
                    </tr>
                </table>
            </div>

            <div class="danger-box">
                <strong>Facebook 2019:</strong> 600 million passwords stored in plaintext logs. 20,000 employees could see them for 7 years!
            </div>
        </div>

        <!-- Failed Solution: Encoding -->
        <div class="section">
            <h2>First Attempt: "Let's Encode the Passwords!"</h2>

            <p>Someone might think: "What if we encode passwords so they're not readable?"</p>

            <h3>Simple Encoding Example: Caesar Cipher</h3>

            <div class="diagram">
<pre>
CAESAR CIPHER (Shift by 3)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Original:  P  A  S  S  W  O  R  D
Shift +3:  S  D  V  V  Z  R  U  G

Stored in DB: "SDVVZRUG"

Looks safe? NOPE!
</pre>
            </div>

            <pre><code class="language-python"># Simple Caesar cipher encoding
def encode_password(password):
    return ''.join(chr(ord(c) + 3) for c in password)

def decode_password(encoded):
    return ''.join(chr(ord(c) - 3) for c in encoded)

# Anyone who knows the encoding can reverse it!
encoded = encode_password("password")  # "sdvvzrug"
original = decode_password(encoded)     # "password" - OOPS!</code></pre>

            <h3>What About Base64?</h3>

            <div class="diagram">
<pre>
BASE64 ENCODING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"password" â†’ Base64 â†’ "cGFzc3dvcmQ="

Looks encrypted? IT'S NOT!

Anyone can decode:
"cGFzc3dvcmQ=" â†’ Base64 decode â†’ "password"

Base64 is for DATA FORMAT, not SECURITY!
</pre>
            </div>

            <div class="warning-box">
                <strong>Key Insight:</strong> Encoding is <strong>REVERSIBLE by design</strong>. Anyone who knows the encoding scheme can decode it. There's no secret key needed!
            </div>

            <h3>Popular Encodings (and Why We Use Them)</h3>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Encoding</th>
                        <th>Purpose</th>
                        <th>Security?</th>
                    </tr>
                    <tr>
                        <td><strong>Base64</strong></td>
                        <td>Send binary data as text (emails, URLs)</td>
                        <td>âŒ None - anyone can decode</td>
                    </tr>
                    <tr>
                        <td><strong>URL Encoding</strong></td>
                        <td>Handle special chars in URLs (%20 = space)</td>
                        <td>âŒ None - just formatting</td>
                    </tr>
                    <tr>
                        <td><strong>ASCII/UTF-8</strong></td>
                        <td>Represent text as bytes</td>
                        <td>âŒ None - standard format</td>
                    </tr>
                </table>
            </div>

            <div class="info-box">
                <strong>Bottom Line:</strong> Encoding is for <strong>format conversion</strong>, not security. We need something that <strong>cannot be reversed</strong> - that's where HASHING comes in!
            </div>
        </div>

        <!-- Era 2: Hashing -->
        <div class="section">
            <h2>Era 2: Hashing (One-Way Transformation)</h2>

            <h3>What is Hashing? (The Simple Version)</h3>

            <div class="diagram">
<pre>
SIMPLE HASH: Letter Position Sum
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"CAT" â†’ C(3) + A(1) + T(20) = 24
"DOG" â†’ D(4) + O(15) + G(7) = 26

Given hash "24", what was the original word?
â€¢ CAT = 24 âœ“
â€¢ ACT = 24 âœ“
â€¢ TAC = 24 âœ“
â€¢ X = 24 âœ“

YOU CAN'T REVERSE IT! That's the point.
</pre>
            </div>
<!-- Hideable Note: Golden Rules of Hashing -->
<details class="note">
  <summary><strong>Note: The Three Golden Rules of Hashing</strong></summary>

  <div class="concept">

    <h4>1. One-Way (Irreversible)</h4>
    <p>
      Hashing is <strong>not encryption</strong>.
      You can verify an input by hashing it again, but you can never recover the original input from the hash.
      There is no â€œdecryptingâ€ a hash â€” only re-hashing and comparing.
    </p>

<pre>
Input: password123 â†’ Hash: a7f9...
Given a7f9..., the original input cannot be determined.
</pre>

  </div>

  <div class="concept">

    <h4>2. Deterministic (Same Input â†’ Same Output)</h4>
    <p>
      A hash function always produces the same output for the same input.
      This consistency is what makes password verification possible.
    </p>

<pre>
Input: apple â†’ Hash: a7f9...
Input: apple â†’ Hash: a7f9...   âœ“ Always identical
</pre>

  </div>

  <div class="concept">

    <h4>3. Avalanche Effect (Tiny Change â†’ Massive Difference)</h4>
    <p>
      Even a one-character change in the input produces a completely different hash.
      The outputs look unrelated on purpose.
    </p>

<pre>
Input: apple â†’ Hash: a7f9...
Input: applE â†’ Hash: 8b32...   âœ— Totally different
</pre>

  </div>

</details>

            <p><strong>Real hashing algorithms</strong> (MD5, SHA) work similarly but are much more complex:</p>

            <pre><code class="language-python">import hashlib

# MD5 hashing - CANNOT be reversed!
password = "password"
hashed = hashlib.md5(password.encode()).hexdigest()
print(hashed)  # "5f4dcc3b5aa765d61d8327deb882cf99"

# Same input ALWAYS gives same output
hashlib.md5("password".encode()).hexdigest()  # Same hash
hashlib.md5("password".encode()).hexdigest()  # Same hash

# Different input gives DIFFERENT output
hashlib.md5("password1".encode()).hexdigest()  # Completely different!</code></pre>

            <h3>Brief History of Hash Functions</h3>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Algorithm</th>
                        <th>Year</th>
                        <th>Output Size</th>
                        <th>Status Today</th>
                    </tr>
                    <tr>
                        <td>MD5</td>
                        <td>1991</td>
                        <td>128-bit</td>
                        <td style="color: var(--danger-color);">â˜ ï¸ Broken</td>
                    </tr>
                    <tr>
                        <td>SHA-1</td>
                        <td>1995</td>
                        <td>160-bit</td>
                        <td style="color: var(--danger-color);">â˜ ï¸ Broken</td>
                    </tr>
                    <tr>
                        <td>SHA-256</td>
                        <td>2001</td>
                        <td>256-bit</td>
                        <td style="color: var(--warning-color);">âš ï¸ Good for checksums, weak for passwords</td>
                    </tr>
                </table>
            </div>

            <h3>The Attack: Rainbow Tables</h3>

            <p>Attackers realized: "We can't reverse hashes, but we can <strong>pre-compute</strong> them!"</p>

            <div class="diagram">
<pre>
RAINBOW TABLE ATTACK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Step 1: Pre-compute hashes for millions of common passwords

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Password      â”‚ MD5 Hash                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ password      â”‚ 5f4dcc3b5aa765d61d8327deb882cf99     â”‚
â”‚ 123456        â”‚ e10adc3949ba59abbe56e057f20f883e     â”‚
â”‚ qwerty        â”‚ d8578edf8458ce06fbc5bb76a58c5ca4     â”‚
â”‚ letmein       â”‚ 0d107d09f5bbe40cade3de5c71e9e9b7     â”‚
â”‚ ... 10 billion more passwords ...                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Steal database with hashes

Step 3: Look up each hash in the table

Stolen hash: 5f4dcc3b5aa765d61d8327deb882cf99
Table lookup â†’ Password is "password"

Time: INSTANT (just a database lookup!)
</pre>
            </div>

            <div class="info-box">
                <strong>Rainbow tables exist!</strong> You can download pre-computed tables with billions of password-hash pairs. If two users have the same password, they have the same hash - crack one, crack both!
            </div>

            <div class="danger-box">
                <strong>LinkedIn 2012:</strong> 117 million passwords stored as unsalted SHA-1. 90% were cracked within days using rainbow tables!
            </div>
        </div>

        <!-- Era 3: Salted Hashing -->
        <div class="section">
            <h2>Era 3: Salted Hashing</h2>

            <h3>What is a Salt? (Simple Example)</h3>

            <div class="diagram">
<pre>
SALT: A random string added to each password before hashing
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Without Salt (Vulnerable):
  Alice: password â†’ MD5 â†’ 5f4dcc3b...
  Bob:   password â†’ MD5 â†’ 5f4dcc3b...  (SAME HASH!)

With Salt (Protected):
  Alice: "RANDOM123" + password â†’ MD5 â†’ a7b9c2d1...
  Bob:   "XYZSECRET" + password â†’ MD5 â†’ e3f4g5h6... (DIFFERENT!)

Same password, different hashes!
    <!-- Hideable Note: Why Salt Stops Precomputation -->
<details class="note">
  <summary><strong>Note: Why Salt Kills Pre-computed Attacks</strong></summary>

<pre>
Without salt:
  One rainbow table works for EVERY user.

With salt:
  Each user has a different salt.
  â†’ Hash(password) â‰  Hash(salt + password)
  â†’ Attacker must recompute hashes PER USER.

Precomputation becomes useless.
Only slow, user-by-user brute force remains.
</pre>

</details>

</pre>
            </div>

            <p><strong>Why "Salt"?</strong> Like adding salt to food changes the taste, adding a salt to a password changes its hash. Each user gets their own unique "flavor"!</p>

            <pre><code class="language-python">import hashlib
import os

def register(username, password):
    # Generate random salt for THIS user
    salt = os.urandom(16).hex()  # e.g., "a1b2c3d4e5f6..."

    # Hash password WITH the salt
    salted = salt + password
    hashed = hashlib.sha256(salted.encode()).hexdigest()

    # Store BOTH salt and hash
    db.execute("INSERT INTO users VALUES (?, ?, ?)",
               (username, salt, hashed))

def verify(username, password):
    # Get user's salt and hash from DB
    salt, stored_hash = db.get_salt_and_hash(username)

    # Hash the input with the SAME salt
    input_hash = hashlib.sha256((salt + password).encode()).hexdigest()

    # Compare
    return input_hash == stored_hash</code></pre>

            <div class="success-box">
                <strong>Salt defeats rainbow tables!</strong> Attackers would need a separate rainbow table for every possible salt - computationally impossible!
            </div>

            <h3>The Remaining Problem: Speed</h3>

            <div class="diagram">
<pre>
SHA-256 Speed on Modern GPU:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

22,000,000,000 hashes per second!

To crack an 8-character lowercase password:
â€¢ Possible combinations: 26^8 = 208 billion
â€¢ At 22 billion/second
â€¢ = 9.5 seconds!

Salt stops rainbow tables, but GPUs are TOO FAST for brute force!
</pre>
            </div>
        </div>

        <!-- Era 4: BCrypt -->
        <div class="section">
            <h2>Era 4: BCrypt (The Modern Solution)</h2>

            <p>BCrypt's innovation: <strong>Be SLOW on purpose!</strong></p>

            <h3>How BCrypt Helps</h3>

            <div class="comparison-grid">
                <div class="comparison-item" style="background: #d3f9d8; border: 2px solid #69db7c;">
                    <h4>For Legitimate Users</h4>
                    <ul>
                        <li>Login takes ~0.25 seconds extra</li>
                        <li>Barely noticeable</li>
                        <li>Only happens once per session</li>
                        <li>Worth it for security!</li>
                    </ul>
                </div>
                <div class="comparison-item" style="background: #f8d7da; border: 2px solid #f5a3a8;">
                    <h4>For Attackers</h4>
                    <ul>
                        <li>Must hash EVERY password guess</li>
                        <li>0.25s Ã— 10 million guesses = 29 DAYS</li>
                        <li>GPU speedup is minimal</li>
                        <li>Brute force becomes impractical</li>
                    </ul>
                </div>
            </div>

            <h3>Understanding BCrypt: A Simple Analogy</h3>

            <div class="info-box">
                <strong>Think of BCrypt like a coffee grinder with adjustable settings:</strong>
                <ul style="margin: 0.5rem 0 0 1rem;">
                    <li><strong>Regular hash (SHA-256):</strong> Like an electric coffee grinder - super fast, done in milliseconds</li>
                    <li><strong>BCrypt:</strong> Like a manual hand grinder - you set how many turns (cost factor)</li>
                    <li>For you (grinding one cup): A few extra seconds is fine</li>
                    <li>For an attacker (grinding a million cups): Those seconds add up to years!</li>
                </ul>
            </div>

            <h3>What BCrypt Actually Does</h3>

            <div class="diagram">
<pre>
BCRYPT INTERNALS (Simplified)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Takes your password
2. Generates a random salt (16 bytes)
3. Runs the Blowfish cipher 2^cost times
   (cost=12 means 4,096 iterations!)
4. Each iteration is CPU-intensive
5. Output: salt + hash combined

The "cost factor" is adjustable:
â€¢ cost=10: ~100ms (minimum acceptable)
â€¢ cost=12: ~250ms (recommended)
â€¢ cost=14: ~1 second (high security)

As computers get faster, INCREASE the cost!
</pre>
            </div>

            <h3>BCrypt Output Structure - What Does It Mean?</h3>

            <p>When you hash a password with BCrypt, you get a string like this:</p>

            <div class="diagram">
<pre>
BCrypt OUTPUT BREAKDOWN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.J6Ib8QYFV5eHLq
 â”‚   â”‚  â”‚                      â”‚
 â”‚   â”‚  â”‚                      â””â”€â”€ Hash (31 chars)
 â”‚   â”‚  â”‚                          The actual hashed password
 â”‚   â”‚  â”‚
 â”‚   â”‚  â””â”€â”€ Salt (22 chars)
 â”‚   â”‚      Random data, unique per password
 â”‚   â”‚      "LQv3c1yqBWVHxkd0LHAkCO"
 â”‚   â”‚
 â”‚   â””â”€â”€ Cost Factor (2 digits)
 â”‚       "12" means 2^12 = 4,096 iterations
 â”‚
 â””â”€â”€ Algorithm Version
     "2b" = modern BCrypt

Everything needed for verification is IN THE HASH ITSELF!
</pre>
            </div>

            <div class="success-box">
                <strong>Why This Is Clever:</strong> The salt is stored WITH the hash! No separate salt column needed in your database. When verifying:
                <ol style="margin: 0.5rem 0 0 1rem;">
                    <li>BCrypt extracts the salt from the stored hash</li>
                    <li>Hashes the input password with that same salt</li>
                    <li>Compares the results</li>
                </ol>
            </div>

            <h3>BCrypt Step-by-Step (Visual)</h3>

            <div class="diagram">
<pre>
HOW BCRYPT HASHES YOUR PASSWORD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Your Password: "secret123"
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 1: Generate Random Salt           â”‚
â”‚  salt = "Xd3kJp9mQwRt2sBv"              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 2: Combine Password + Salt        â”‚
â”‚  input = "secret123" + salt             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 3: Run Blowfish 2^12 times        â”‚
â”‚                                         â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”       â”‚
â”‚    â”‚Round â”‚â”€â”€â–ºâ”‚Round â”‚â”€â”€â–ºâ”‚Round â”‚â”€â”€â–º... â”‚
â”‚    â”‚  1   â”‚   â”‚  2   â”‚   â”‚  3   â”‚ 4096x â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                         â”‚
â”‚  Each round: CPU-intensive work         â”‚
â”‚  This is what makes it SLOW!            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 4: Combine Everything             â”‚
â”‚                                         â”‚
â”‚  $2b$12$Xd3kJp9mQwRt2sBv...Hash...     â”‚
â”‚    â”‚   â”‚  â”‚              â”‚              â”‚
â”‚    â”‚   â”‚  Salt           Hash           â”‚
â”‚    â”‚   Cost                             â”‚
â”‚    Version                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
            </div>

            <h3>Why BCrypt Resists GPU Attacks</h3>

            <div class="warning-box">
                <strong>Regular hashes (SHA-256) on GPUs:</strong> GPUs are designed for parallel processing - they can run thousands of simple calculations simultaneously. That's why they can compute billions of SHA-256 hashes per second.
            </div>

            <div class="success-box">
                <strong>BCrypt's defense:</strong> BCrypt uses the Blowfish cipher which requires:
                <ul style="margin: 0.5rem 0 0 1rem;">
                    <li><strong>4KB of RAM per hash</strong> - GPUs have limited memory per core</li>
                    <li><strong>Sequential memory access</strong> - GPUs prefer parallel access patterns</li>
                    <li><strong>Branching operations</strong> - GPUs are bad at unpredictable branches</li>
                </ul>
                Result: GPUs can't parallelize BCrypt effectively. A $5000 GPU isn't much faster than a $50 CPU at BCrypt!
            </div>

            <h3>Speed Comparison</h3>

            <div class="diagram">
<pre>
CRACKING TIME COMPARISON
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    Hashes/Second    8-char Password
SHA-256:           22,000,000,000    2 minutes
BCrypt (cost 12):       1,400        63 YEARS

Same password. Same attacker. 16 MILLION times harder!
</pre>
            </div>

            <h3>Historical Note</h3>

            <div class="info-box">
                <strong>BCrypt History:</strong>
                <ul style="margin: 0.5rem 0 0 1rem;">
                    <li><strong>1999:</strong> Created by Niels Provos and David MaziÃ¨res</li>
                    <li>Based on the Blowfish cipher (1993)</li>
                    <li>First algorithm designed specifically for password hashing</li>
                    <li>Introduced "adaptive cost" - can be made slower as hardware improves</li>
                    <li>Still the industry standard 25+ years later!</li>
                </ul>
            </div>

            <h3>Try It Yourself!</h3>

            <div class="success-box">
                <strong>ğŸ”— Online BCrypt Generator:</strong><br>
                <a href="https://bcrypt-generator.com/" target="_blank" style="color: #1971c2;">https://bcrypt-generator.com/</a><br><br>
                Try hashing the same password multiple times - notice the hash is different each time (because of the random salt)!
            </div>

            <pre><code class="language-python">import bcrypt

# Hash a password
password = "mypassword123"
hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12))
print(hashed)  # $2b$12$LQv3c1yqBWVHxkd0LHAkCO...

# Verify a password
if bcrypt.checkpw("mypassword123".encode(), hashed):
    print("Password correct!")
else:
    print("Wrong password!")</code></pre>
        </div>

        <!-- Evolution Summary (Moved to End) -->
        <div class="section">
            <h2>Summary: The Evolution of Password Storage</h2>

            <div class="table-container">
                <table>
                    <tr>
                        <th>Era</th>
                        <th>Method</th>
                        <th>Status</th>
                        <th>Why It Failed/Worked</th>
                    </tr>
                    <tr>
                        <td>1960s</td>
                        <td>Plaintext</td>
                        <td style="color: var(--danger-color);">â˜ ï¸ DANGEROUS</td>
                        <td>Anyone with DB access sees all passwords</td>
                    </tr>
                    <tr>
                        <td>1980s</td>
                        <td>Encoding (Base64, etc.)</td>
                        <td style="color: var(--danger-color);">â˜ ï¸ USELESS</td>
                        <td>Reversible - provides zero security</td>
                    </tr>
                    <tr>
                        <td>1990s</td>
                        <td>MD5/SHA (no salt)</td>
                        <td style="color: var(--danger-color);">â˜ ï¸ BROKEN</td>
                        <td>Rainbow tables crack in seconds</td>
                    </tr>
                    <tr>
                        <td>2000s</td>
                        <td>SHA + Salt</td>
                        <td style="color: var(--warning-color);">âš ï¸ WEAK</td>
                        <td>GPUs crack billions per second</td>
                    </tr>
                    <tr>
                        <td>1999+</td>
                        <td>BCrypt</td>
                        <td style="color: var(--success-color);">âœ… GOOD</td>
                        <td>Intentionally slow, adaptive cost</td>
                    </tr>
                    <tr>
                        <td>2015+</td>
                        <td>Argon2</td>
                        <td style="color: var(--success-color);">âœ… BEST</td>
                        <td>Memory-hard, resists GPU attacks</td>
                    </tr>
                </table>
            </div>

            <div class="success-box">
                <strong>The Golden Rule:</strong> Use BCrypt (or Argon2) with a cost factor of at least 12. Never roll your own password hashing!
            </div>
        </div>

        <!-- Quiz 1 -->
        <div class="quiz-container">
            <div class="quiz-title">ğŸ§  Quiz 1: Password Storage</div>
            <p style="margin-bottom: 1rem;">Why doesn't Base64 encoding protect passwords?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer(this, true)">
                    A) Base64 is reversible - anyone can decode it
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    B) Base64 produces short hashes
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    C) Base64 is too slow
                </div>
                <div class="quiz-option" onclick="checkAnswer(this, false)">
                    D) Base64 needs a salt
                </div>
            </div>
            <div class="quiz-feedback" id="quiz-feedback"></div>
        </div>

        <!-- Quiz 2 -->
        <div class="quiz-container">
            <div class="quiz-title">ğŸ§  Quiz 2: BCrypt</div>
            <p style="margin-bottom: 1rem;">What is the main advantage of BCrypt over SHA-256 for password hashing?</p>
            <div class="quiz-options">
                <div class="quiz-option" onclick="checkAnswer2(this, false)">
                    A) BCrypt produces shorter hashes
                </div>
                <div class="quiz-option" onclick="checkAnswer2(this, false)">
                    B) BCrypt is reversible for password recovery
                </div>
                <div class="quiz-option" onclick="checkAnswer2(this, true)">
                    C) BCrypt is intentionally slow, making brute force attacks impractical
                </div>
                <div class="quiz-option" onclick="checkAnswer2(this, false)">
                    D) BCrypt doesn't need a salt
                </div>
            </div>
            <div class="quiz-feedback" id="quiz-feedback-2"></div>
        </div>

        <script>
        function checkAnswer2(element, isCorrect) {
            const container = element.closest('.quiz-container');
            const options = container.querySelectorAll('.quiz-option');
            const feedback = container.querySelector('.quiz-feedback');
            options.forEach(opt => {
                opt.classList.add('disabled');
                if (opt.onclick.toString().includes('true')) {
                    opt.classList.add('correct');
                }
            });
            if (isCorrect) {
                element.classList.add('correct');
                feedback.className = 'quiz-feedback show correct';
                feedback.innerHTML = 'âœ… Correct! BCrypt\'s slowness is its superpower. A legitimate user waiting 250ms is fine, but an attacker trying millions of guesses will be stuck for years!';
            } else {
                element.classList.add('incorrect');
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = 'âŒ Not quite. BCrypt is specifically designed to be slow (adjustable via cost factor), making brute-force attacks computationally impractical.';
            }
        }
        </script>

        <div class="page-nav">
            <a href="03_ways_of_auth.html">â† Ways of Authentication</a>
            <a href="05_encoding.html">Next: Encoding vs Encryption vs Hashing â†’</a>
        </div>

        <footer>
            <p>Page 4 of 8 - Authentication Guide</p>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function checkAnswer(element, isCorrect) {
            const options = document.querySelectorAll('.quiz-option');
            const feedback = document.getElementById('quiz-feedback');
            options.forEach(opt => {
                opt.classList.add('disabled');
                if (opt.onclick.toString().includes('true')) {
                    opt.classList.add('correct');
                }
            });
            if (isCorrect) {
                element.classList.add('correct');
                feedback.className = 'quiz-feedback show correct';
                feedback.innerHTML = 'âœ… Correct! Base64 is ENCODING, not ENCRYPTION or HASHING. Anyone can decode it instantly - it provides zero security!';
            } else {
                element.classList.add('incorrect');
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = 'âŒ Not quite. The key issue is that Base64 is completely reversible. It\'s designed for format conversion, not security.';
            }
        }
    </script>
</body>
</html>
